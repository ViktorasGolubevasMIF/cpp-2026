{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Prad\u017eia","text":"<p>Naujienos (Atnaujinta: 2026-02-25)</p> <ul> <li>\u012ekelta 2-os paskaitos med\u017eiaga.</li> </ul>"},{"location":"#naudingi-irankiai","title":"\ud83d\udee0\ufe0f Naudingi \u012frankiai","text":"<p>\u0160iuos \u012frankius naudosime viso kurso metu. Rekomenduoju i\u0161sisaugoti.</p> <p>Compiler Explorer (Godbolt)</p> <p>C++ Insights</p> <p>Python Tutor (Vizualizacija)</p>"},{"location":"#c-reference","title":"C++ Reference","text":""},{"location":"#kurso-struktura","title":"\ud83d\uddfa\ufe0f Kurso strukt\u016bra","text":"<p>Kursas suskirstytas \u012f tris loginius etapus (juodra\u0161tis):</p>"},{"location":"#1-nuo-c-link-c-procedurinis-pagrindas","title":"1. Nuo C link C++ (Proced\u016brinis pagrindas)","text":"<p>Prisiminsime C kalb\u0105, rodykles (pointers), atminties valdym\u0105 ir pereisime prie C++ sintaks\u0117s pagerinim\u0173 (references, overload, namespace).</p>"},{"location":"#2-objektinis-programavimas-oop","title":"2. Objektinis Programavimas (OOP)","text":"<p>Pagrindin\u0117 kurso dalis. Klas\u0117s, inkapsuliacija, <code>Stack</code> evoliucija, konstruktoriai/destruktoriai, Rule of Three/Five, paveld\u0117jimas ir polimorfizmas.</p>"},{"location":"#3-stl-ir-modern-c","title":"3. STL ir Modern C++","text":"<p>Susipa\u017einsime su standartine biblioteka (<code>std::vector</code>, <code>std::map</code>), algoritmais ir i\u0161maniosiomis rodykl\u0117mis (<code>smart pointers</code>).</p>"},{"location":"Kursas/Kurso_Struktura/","title":"OBJEKTINIS PROGRAMAVIMAS C++, 2026","text":""},{"location":"Kursas/Kurso_Struktura/#kurso-struktura-teminiai-skyriai-paskaitos","title":"Kurso strukt\u016bra: Teminiai skyriai -&gt; Paskaitos","text":""},{"location":"Kursas/Kurso_Struktura/#teminiai-skyriai-temine-struktura","title":"TEMINIAI SKYRIAI (TEMIN\u0116 STRUKT\u016aRA)","text":""},{"location":"Kursas/Kurso_Struktura/#1-skyrius-evoliucija-nuo-c-iki-modern-c","title":"1 skyrius. EVOLIUCIJA: Nuo C iki Modern C++","text":""},{"location":"Kursas/Kurso_Struktura/#11-is-monolito-i-moduli","title":"1.1. I\u0161 Monolito \u012f Modul\u012f","text":"<ul> <li>Programos dekompozicija</li> <li>Kompiliavimo vienetai (compilation units)</li> <li>Antra\u0161t\u0117s/implementacijos atskyrimas (header/implementation)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#12-informacijos-slepimas-pradzia","title":"1.2. Informacijos sl\u0117pimas. Prad\u017eia","text":"<ul> <li>Statiniai kintamieji (<code>static</code>)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#13-inkapsuliacija-pradzia","title":"1.3. Inkapsuliacija. Prad\u017eia","text":"<ul> <li>Vartotojo apibr\u0117\u017eti tipai (User-Defined Types)</li> <li>Inkapsuliacija (Encapsulation) C b\u016bdu</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#14-gyvavimo-ciklas","title":"1.4. Gyvavimo ciklas","text":"<ul> <li>Nepermatomos rodykl\u0117s (opaque pointers)</li> <li>Rankinis resurs\u0173 valdymas</li> <li>RAII. Prad\u017eia</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#15-pazangios-c-technikos-priedas-10a-d-perdaryti","title":"1.5. Pa\u017eangios C technikos (Priedas 10A-D) - perdaryti","text":"<ul> <li>Tip\u0173 alijavimas (<code>typedef aliasing</code>)</li> <li>Konstanti\u0161kumo taisykl\u0117s (<code>const correctness</code>)</li> <li>Funkcij\u0173 rodykliai (<code>function pointers</code>) polimorfizmui</li> <li>Bendrinio rodyklio technika (<code>void pointer generics</code>)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#16-suolis-i-c-perdaryti","title":"1.6. \u0160uolis \u012f C++ - perdaryti","text":"<ul> <li><code>class</code> kaip sprendimas</li> <li><code>Constructor</code>/<code>Destructor</code> automatizacija</li> <li><code>private</code>/<code>public</code> vykdymas kompiliatoriaus lygmenyje</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#2-skyrius-klases-anatomija","title":"2 skyrius. KLAS\u0116S ANATOMIJA","text":""},{"location":"Kursas/Kurso_Struktura/#21-klases-pagrindai","title":"2.1. KLAS\u0116S pagrindai","text":"<ul> <li><code>struct</code> vs <code>class</code></li> <li>Funkcijos-nariai (member functions)</li> <li><code>this</code> rodykl\u0117</li> <li>Konstruktoriai: numatytasis (<code>default</code>), parametrizuotas</li> <li>Destruktorius</li> <li>Inicializacija vs Priskyrimas</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#22-prieigos-kontrole","title":"2.2. Prieigos kontrol\u0117","text":"<ul> <li><code>public</code>/<code>private</code>/<code>protected</code></li> <li>Draugi\u0161kos funkcijos/klas\u0117s (<code>friend</code>)</li> <li>Getteri\u0173/Setteri\u0173 \u0161ablonas (getter/setter)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#23-raii-principas","title":"2.3. RAII principas","text":"<ul> <li>Resurs\u0173 gavimas yra inicializacija (Resource Acquisition Is Initialization)</li> <li>Destruktoriaus atsakomyb\u0117</li> <li>Automatinis valymas (automatic cleanup)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#3-skyrius-geresnis-c","title":"3 skyrius. GERESNIS C","text":""},{"location":"Kursas/Kurso_Struktura/#31-nuorodos-references","title":"3.1. Nuorodos (References)","text":"<ul> <li>lvalue nuorodos</li> <li>Nuoroda vs rodykl\u0117</li> <li>Nuorodos kaip funkcij\u0173 parametrai</li> <li>Gr\u0105\u017einimas per nuorod\u0105 (return by reference)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#32-auto-ir-tipo-isvedimas","title":"3.2. Auto ir tipo i\u0161vedimas","text":"<ul> <li><code>auto</code> rakta\u017eodis; kada naudoti/nenaudoti</li> <li><code>decltype</code></li> </ul>"},{"location":"Kursas/Kurso_Struktura/#33-ciklas-su-diapazonu-range-based-loops","title":"3.3. Ciklas su diapazonu (Range-based loops)","text":"<ul> <li><code>for (auto&amp; elem : container)</code>; kada efektyvu</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#34-nullptr","title":"3.4. Nullptr","text":"<ul> <li>vs <code>NULL</code> vs <code>0</code></li> </ul>"},{"location":"Kursas/Kurso_Struktura/#35-vieninga-inicializacija-uniform-initialization","title":"3.5. Vieninga inicializacija (Uniform initialization)","text":"<ul> <li>Riestini\u0173 skliaust\u0173 inicializacija <code>{}</code></li> <li>Tiesiogin\u0117 inicializacija <code>()</code></li> </ul>"},{"location":"Kursas/Kurso_Struktura/#4-skyrius-kopijavimo-semantika","title":"4 skyrius. KOPIJAVIMO SEMANTIKA","text":""},{"location":"Kursas/Kurso_Struktura/#41-numatytasis-kopijavimo-elgesys","title":"4.1. Numatytasis kopijavimo elgesys","text":"<ul> <li>Pavir\u0161inio kopijavimo (shallow copy) problema</li> <li>Bitinis kopijavimas (bitwise copy)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#42-kopijavimo-konstruktorius-copy-constructor","title":"4.2. Kopijavimo konstruktorius (Copy Constructor)","text":"<ul> <li>Kada kvie\u010diamas</li> <li>Giliojo kopijavimo (deep copy) implementacija</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#43-kopijavimo-priskyrimo-operatorius-copy-assignment-operator","title":"4.3. Kopijavimo priskyrimo operatorius (Copy Assignment Operator)","text":"<ul> <li><code>operator=</code> perkrovimas (overloading)</li> <li>Sav\u0119s priskyrimo patikra (self-assignment check)</li> <li>\"Kopijuok-ir-keisk\" idioma (copy-and-swap idiom)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#44-triju-taisykle-rule-of-3","title":"4.4. Trij\u0173 taisykl\u0117 (Rule of 3)","text":"<ul> <li>Destruktorius + Kopijos konstruktorius + Kopijos priskyrimas</li> <li>Kada reikalinga</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#5-skyrius-oop-principai-4-kolonos","title":"5 skyrius. OOP PRINCIPAI (4 kolonos)","text":""},{"location":"Kursas/Kurso_Struktura/#51-inkapsuliacija-encapsulation","title":"5.1. Inkapsuliacija (Encapsulation)","text":"<ul> <li>Apibendrinimas i\u0161 Klas\u0117s anatomijos</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#52-paveldejimas-inheritance","title":"5.2. Paveld\u0117jimas (Inheritance)","text":"<ul> <li><code>public</code>/<code>protected</code>/<code>private</code> paveld\u0117jimas</li> <li>Konstruktori\u0173/destruktori\u0173 grandin\u0117</li> <li><code>is-a</code> ry\u0161ys</li> <li>Bazin\u0117s klas\u0117s inicializacija (base class initialization)</li> <li>Apsaugot\u0173 nari\u0173 (protected members) prieiga</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#53-polimorfizmas-polymorphism","title":"5.3. Polimorfizmas (Polymorphism)","text":"<ul> <li>Funkcij\u0173 perkrovimas (function overloading) - kompiliavimo metu</li> <li>Virtualios funkcijos (<code>virtual</code> functions) - vykdymo metu (runtime)</li> <li>Virtuali\u0173 funkcij\u0173 lentel\u0117 (vtable)</li> <li><code>override</code> rakta\u017eodis</li> <li>Grynai virtuali (pure <code>virtual</code>) <code>=0</code></li> <li>Abstrak\u010dios klas\u0117s (abstract classes)</li> <li>S\u0105sajos \u0161ablonas (interface pattern)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#54-abstrakcija-abstraction","title":"5.4. Abstrakcija (Abstraction)","text":"<ul> <li>S\u0105saja (interface) vs Implementacija</li> <li>Priklausomybi\u0173 inversija (dependency inversion)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#6-skyrius-modern-c-c111417202326","title":"6 skyrius. MODERN C++ (C++11/14/17/20/23/26)","text":""},{"location":"Kursas/Kurso_Struktura/#61-rvalue-nuorodos","title":"6.1. rvalue nuorodos","text":"<ul> <li>lvalue vs rvalue</li> <li><code>&amp;&amp;</code> sintaks\u0117</li> <li><code>std::move</code></li> </ul>"},{"location":"Kursas/Kurso_Struktura/#62-perkelimo-konstruktorius-move-constructor","title":"6.2. Perk\u0117limo konstruktorius (Move Constructor)","text":"<ul> <li>Kada kvie\u010diamas</li> <li>Resurs\u0173 \"vagyst\u0117\" (resource stealing)</li> <li><code>noexcept</code></li> </ul>"},{"location":"Kursas/Kurso_Struktura/#63-perkelimo-priskyrimo-operatorius-move-assignment","title":"6.3. Perk\u0117limo priskyrimo operatorius (Move Assignment)","text":"<ul> <li>\"Perkelk-ir-sukeisk\" \u0161ablonas (move-and-swap pattern)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#64-penkiu-taisykle-rule-of-5","title":"6.4. Penki\u0173 taisykl\u0117 (Rule of 5)","text":"<ul> <li>Trij\u0173 taisykl\u0117 + Perk\u0117limo operacijos</li> <li>Nulio taisykl\u0117 (Rule of 0) - kada nereikia nieko</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#65-ismaniosios-rodykles-smart-pointers","title":"6.5. I\u0161maniosios rodykl\u0117s (Smart Pointers)","text":"<ul> <li><code>unique_ptr</code> (nuosavyb\u0117)</li> <li><code>shared_ptr</code> (nuorod\u0173 skai\u010diavimas, reference counting)</li> <li><code>weak_ptr</code></li> <li><code>make_unique</code>/<code>make_shared</code></li> <li>RAII \"tobulumas\"</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#7-skyrius-operatoriu-perkrovimas","title":"7 skyrius. OPERATORI\u0172 PERKROVIMAS","text":""},{"location":"Kursas/Kurso_Struktura/#71-aritmetiniai-operatoriai","title":"7.1. Aritmetiniai operatoriai","text":"<ul> <li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> kaip narys/draugas (<code>member</code>/<code>friend</code>)</li> <li>Sud\u0117tinis priskyrimas <code>+=</code>, <code>-=</code></li> </ul>"},{"location":"Kursas/Kurso_Struktura/#72-palyginimo-operatoriai","title":"7.2. Palyginimo operatoriai","text":"<ul> <li><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Erdv\u0117laivio operatorius (<code>spaceship operator</code>) <code>&lt;=&gt;</code> (C++20)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#73-srauto-operatoriai","title":"7.3. Srauto operatoriai","text":"<ul> <li><code>operator&lt;&lt;</code> / <code>operator&gt;&gt;</code></li> <li><code>friend</code> reikalavimas</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#74-indeksavimo-operatorius","title":"7.4. Indeksavimo operatorius <code>[]</code>","text":"<ul> <li><code>const</code>/ne-<code>const</code> versijos</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#75-funkcijos-iskvietimo-operatorius","title":"7.5. Funkcijos i\u0161kvietimo operatorius <code>()</code>","text":"<ul> <li>Funktoriai (<code>functors</code>)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#8-skyrius-sablonu-pagrindai","title":"8 skyrius. \u0160ABLON\u0172 PAGRINDAI","text":""},{"location":"Kursas/Kurso_Struktura/#81-funkciju-sablonai-function-templates","title":"8.1. Funkcij\u0173 \u0161ablonai (Function templates)","text":"<ul> <li>\u0160ablono sintaks\u0117 (<code>template</code> syntax)</li> <li>Tipo i\u0161vedimas (type deduction)</li> <li>\u0160ablono specializacija (template specialization)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#82-klasiu-sablonai-class-templates","title":"8.2. Klasi\u0173 \u0161ablonai (Class templates)","text":"<ul> <li>\u0160ablono parametrai (template parameters)</li> <li>\u0160ablono instanciacija (template instantiation)</li> <li>Atskiro kompiliavimo problema</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#9-skyrius-stl-pagrindai","title":"9 skyrius. STL PAGRINDAI","text":""},{"location":"Kursas/Kurso_Struktura/#91-konteineriu-pagrindai","title":"9.1. Konteineri\u0173 pagrindai","text":"<ul> <li><code>std::array</code> (fiksuoto dyd\u017eio)</li> <li><code>std::vector</code> (dinaminis)</li> <li>Bendra konteineri\u0173 s\u0105saja</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#92-iteratoriai","title":"9.2. Iteratoriai","text":"<ul> <li>Iteratoriaus koncepcija</li> <li><code>begin()</code>/<code>end()</code></li> <li>Iteratori\u0173 kategorijos</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#93-algoritmai","title":"9.3. Algoritmai","text":"<ul> <li><code>std::sort</code>, <code>std::find</code></li> <li>Lambda i\u0161rai\u0161kos (pagrindin\u0117s)</li> <li>Algoritmas + Iteratorius \u0161ablonas</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#94-kiti-konteineriai-apzvalga","title":"9.4. Kiti konteineriai (ap\u017evalga)","text":"<ul> <li><code>std::string</code></li> <li><code>std::list</code></li> <li><code>std::map</code></li> <li><code>std::set</code></li> <li>Kada k\u0105 naudoti</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#10-skyrius-isimciu-apdorojimas","title":"10 skyrius. I\u0160IM\u010cI\u0172 APDOROJIMAS","text":""},{"location":"Kursas/Kurso_Struktura/#101-trycatchthrow","title":"10.1. <code>try</code>/<code>catch</code>/<code>throw</code>","text":"<ul> <li>I\u0161im\u010di\u0173 sklidimas (exception propagation)</li> <li>Steko atsukimas (stack unwinding)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#102-standartines-isimtys","title":"10.2. Standartin\u0117s i\u0161imtys","text":"<ul> <li><code>std::exception</code> hierarchija</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#103-raii-ir-isimtys","title":"10.3. RAII ir i\u0161imtys","text":"<ul> <li>Kod\u0117l RAII kriti\u0161kas</li> <li>I\u0161im\u010di\u0173 saugumo lygiai (exception safety levels)</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#104-noexcept","title":"10.4. Noexcept","text":"<ul> <li>Kada ir kod\u0117l</li> </ul>"},{"location":"Kursas/Kurso_Struktura/#paskaitu-projekcija-i-temines-dalis-siekiamybe","title":"PASKAIT\u0172 PROJEKCIJA \u012e TEMINES DALIS (siekiamyb\u0117 \ud83d\ude80)","text":"# Paskaitos pavadinimas Objektas Temin\u0117s dalys Fokusas 1 \u012evadas + C evoliucija I dalis Stack (C, stages 1-5) Intro + I.1, I.2 Moduliarumas, kompiliacija, info hiding prad\u017eia. \u012esib\u0117g\u0117jimas su C 2 C evoliucija II + \u0161uolis \u012f C++ Stack (C, 6-9) \u2192 Stack-C++ \"v0\" I.3, I.4, I.5 <code>Factory</code>, <code>lifecycle</code> problema \u2192 <code>CLASS</code> sprendimas. Wow! Fixed <code>array</code> dar. 3 Klas\u0117s anatomija: paprasti objektai Student, Point II.1, II.2, II.3 (basic) <code>class</code> sintaks\u0117, konstruktoriai, <code>getters</code>/<code>setters</code>, <code>this</code>, <code>access control</code> 4 Geresnis C Student su <code>refs</code> III (visa) <code>References</code>, <code>auto</code>, <code>range-loops</code>, <code>nullptr</code>, <code>uniform init</code> 5 STL \u012fvadas: konteineriai Student + <code>vector</code> IX.1, IX.2 (dalis) <code>std::array</code>, <code>std::vector</code>, iteratoriai, <code>begin</code>/<code>end</code>, <code>range-based</code> praktikoje 6 RAII ir destruktorius String II.3 (full) + IV.1 <code>char*</code> dinamika, destruktorius, <code>shallow copy</code> problema, \"\u017eemi\u0161kas\" pavyzdys 7 Copy Constructor String IV.2 <code>Deep copy</code>, kada kvi\u010diamas, <code>String(const String&amp;)</code> 8 Copy Assignment + Rule of Three String IV.3, IV.4 <code>operator=</code>, <code>self-assignment</code>, <code>copy-and-swap</code>, <code>Rule of Three</code> 9 Kompozicija \"ant pir\u0161t\u0173\" Course (has Students) V.1 (extend) <code>Shallow</code>/<code>deep</code> lifecycle, <code>has-a</code>, agregacija vs kompozicija 10 Paveld\u0117jimas Shape \u2192 Circle/Rect V.2 <code>Is-a</code>, konstruktori\u0173 <code>chain</code>, <code>protected</code>, base <code>init</code> 11 Polimorfizmas: virtualios funkcijos Shape su <code>draw()</code> V.3 (dalis) <code>Virtual</code>, <code>vtable</code>, <code>override</code>, runtime binding 12 Abstrak\u010dios klas\u0117s ir s\u0105sajos IDrawable, Animal V.3 (finish), V.4 <code>Pure virtual</code> (<code>=0</code>), <code>interface pattern</code>, <code>dependency inversion</code> 13 Move semantika String su <code>move</code> VI.1, VI.2, VI.3, VI.4 <code>Rvalue refs</code>, <code>std::move</code>, Move <code>ctor</code>/<code>assign</code>, <code>Rule of Five</code> 14 Protingi rodykliai + Rule of Zero Stack-C++ su <code>unique_ptr</code> VI.5 + Rule of Zero <code>Smart pointers</code>, <code>RAII</code> tobulumas, compiler-generated methods 15 \u0160ablonai + Kulminacija Stack\\&lt;T&gt; \u2192 <code>std::stack</code> VIII.1, VIII.2 + IX.3 <code>Templates</code>, <code>Stack&lt;T&gt;</code>, connection to STL, exceptions, best practices"},{"location":"Kursas/Kurso_Struktura/#objektu-hierarchija-pagal-sudetinguma","title":"OBJEKT\u0172 HIERARCHIJA PAGAL SUD\u0116TINGUM\u0104","text":""},{"location":"Kursas/Kurso_Struktura/#1-paprastas-objektas-tik-duomenys-prieiga","title":"1. PAPRASTAS objektas (tik duomenys + prieiga)","text":"<ul> <li>Student arba Point arba Date</li> <li>N\u0117ra dinamini\u0173 resurs\u0173 <p>Fokusas: <code>class</code> sintaks\u0117, <code>constructors</code>, <code>getters</code>/<code>setters</code>, <code>access control</code></p> </li> </ul>"},{"location":"Kursas/Kurso_Struktura/#2-kompozicinis-objektas-turi-kitu-objektu","title":"2. KOMPOZICINIS objektas (turi kit\u0173 objekt\u0173)","text":"<ul> <li>Course (turi <code>Student</code>'\u0173 <code>array</code>/<code>vector</code>)</li> <li>Rectangle (turi 2 <code>Point</code>'us) <p>Fokusas: <code>shallow</code> vs <code>deep</code>, objekt\u0173 santykiai, kompozicija</p> </li> </ul>"},{"location":"Kursas/Kurso_Struktura/#3-resursus-valdantis-objektas","title":"3. RESURSUS VALDANTIS objektas","text":"<ul> <li>String (dinaminis <code>char</code> masyvas)</li> <li>Stack (dinaminis masyvas) <p>Fokusas: <code>RAII</code>, destruktorius, <code>copy</code>/<code>move</code> semantika</p> </li> </ul>"},{"location":"Kursas/Kurso_Struktura/#4-polimorfinis-objektas","title":"4. POLIMORFINIS objektas","text":"<ul> <li>Shape \u2192 Circle, Rectangle (<code>inheritance hierarchy</code>)</li> <li>Animal \u2192 Dog, Cat <p>Fokusas: <code>virtual functions</code>, <code>abstract classes</code></p> </li> </ul>"},{"location":"Kursas/Kurso_Struktura/#kritiniai-rysiai-tarp-paskaitu","title":"KRITINIAI RY\u0160IAI TARP PASKAIT\u0172","text":"<pre><code>P1-P2 (Evoliucija) \u2500\u2500\u2500\u2500&gt; P3 (Class) \u2500\u2500\u2500\u2500&gt; P4 (Geresnis C)\n                           \u2502                   \u2502\n                           \u2514\u2500&gt; P6-8 (Copy) \u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2514\u2500&gt; P10 (Inheritance) \u2500\u2500&gt; P11-12 (Polymorphism)\n                                                        \u2502\nP5 (STL basic) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500&gt; P15 (Templates)\n\nP3 (RAII) \u2500\u2500&gt; P13 (Move) \u2500\u2500&gt; P14 (Smart ptr) \u2500\u2500&gt; P15 (Best practices)\n</code></pre>"},{"location":"Kursas/Kurso_Struktura/#papildomi-objektai-seminaramsuzduotims","title":"PAPILDOMI OBJEKTAI SEMINARAMS/U\u017dDUOTIMS","text":"Objektas Kam Sud\u0117tingumas Date Operatori\u0173 perkrovimas (<code>+</code>, <code>-</code>, <code>==</code>, <code>&lt;</code>, <code>&lt;&lt;</code>) Paprastas Fraction Aritmetiniai operatoriai, normalizacija Vidutinis Matrix <code>operator[]</code>, 2D dinaminis masyvas, <code>copy</code>/<code>move</code> Sud\u0117tingas BankAccount Kompozicija (turi <code>Transaction</code>'\u0173 <code>vector</code>) Vidutinis Employee \u2192 Manager <code>Inheritance</code>, <code>virtual</code> salary calculation Vidutinis"},{"location":"Kursas/Kurso_Struktura/#versija","title":"VERSIJA","text":"<p>Data: 2026-02-01 Autorius: Viktoras Golubevas Statusas: Preliminari strukt\u016bra: 13-15 paskait\u0173 i\u0161 10 temini\u0173 skyri\u0173</p>"},{"location":"Paskaitos/01/Parameters_Passing/","title":"Parametr\u0173 perdavimo mechanizmai","text":""},{"location":"Paskaitos/01/Parameters_Passing/#value-pointer-reference","title":"<code>value</code>  | <code>pointer</code> | <code>reference</code>","text":""},{"location":"Paskaitos/01/Parameters_Passing/#reiksme-rodykle-nuoroda","title":"<code>reik\u0161m\u0117</code> | <code>rodykl\u0117</code> |  <code>nuoroda</code>","text":""},{"location":"Paskaitos/01/Parameters_Passing/#1-perdavimas-pagal-reiksme-callpass-by-value","title":"1. Perdavimas pagal reik\u0161m\u0119 (call/pass by value)","text":"<p>Tai vienintelis \"tikras\" C kalbos mechanizmas.</p> <ul> <li>\u012e funkcij\u0105 perduodamos kopijos.</li> <li>Funkcija turi savo lokalius kintamuosius (<code>temp</code>, <code>x</code>, <code>y</code>).</li> <li>Original\u016bs kintamieji <code>main</code> funkcijoje N\u0116RA kei\u010diami.</li> </ul> <p>Tai saugu, bet neefektyvu dideliems objektams ir netinka, kai norime pakeisti original\u0105.</p> <pre><code>void swap_val(int x, int y) { // Gauna \"KOPIJAS\" REIK\u0160MI\u0172 (int x=1, int y=2)\n    int temp = x;\n    x = y;\n    y = temp;\n} // \u010cia \"kopijos\" sunaikinamos. \"Originalai\" a ir b nepakito.\nint main() {\n  int a=1, b=2;\n  swap_val(a,b);\n  /* a=1, b=2 */\n}\n</code></pre> <p>\ud83d\udc49 Python Tutor</p>"},{"location":"Paskaitos/01/Parameters_Passing/#2-c-rodyklemis-imituojamas-perdavimas-pagal-nuoroda-callpass-by-reference","title":"2. C rodykl\u0117mis imituojamas perdavimas pagal nuorod\u0105 (\"call/pass by reference\")","text":"<p>C kalboje nor\u0117dami pakeisti original\u0105, turime \"gudrauti\" naudodami adresus.</p> <ol> <li>Parametrai tampa rodykl\u0117mis (<code>int*</code>).</li> <li>Naudojame i\u0161adresavimo (dereference) operatori\u0173 <code>*</code>, kad pasiektume reik\u0161m\u0119.</li> <li>Kvie\u010diant funkcij\u0105, siun\u010diame adresus (<code>&amp;a</code>).</li> </ol> <pre><code>void swap_ptr(int* x, int* y) { // Gauna \"KOPIJAS\" ADRES\u0172 (int* x=&amp;a, int* y=&amp;b)\n    int temp = *x;\n    *x = *y;       // rodykl\u0117s/i\u0161adresavimo operacija * pritaikyta adres\u0173 \"kopijoms\" \n    *y = temp;     // par\u016bpina prieig\u0105 prie pa\u010di\u0173 \"original\u0173\" funkcijos aplinkoj\n}\nint main() {\n  int a=1, b=2;\n  swap_ptr(&amp;a, &amp;b);\n  /* a=2, b=1 */\n}\n</code></pre> <p>\ud83d\udc49 Python Tutor</p>"},{"location":"Paskaitos/01/Parameters_Passing/#3-c-perdavimas-pagal-nuoroda-callpass-by-reference","title":"3. C++ perdavimas pagal nuorod\u0105 (call/pass by reference)","text":"<p>C++ \u012fveda tikr\u0105j\u012f perdavim\u0105 pagal nuorod\u0105. Nuoroda (<code>int&amp;</code>) \u2013 tai pseudonimas (alias). Tai lyg antras vardas tam pa\u010diam kintamajam.</p> <ul> <li>Sintaks\u0117 \u0161varesn\u0117 (nereikia <code>*</code> ir <code>&amp;</code> funkcijos viduje).</li> <li>Kompiliatorius u\u017etikrina, kad nuoroda visada \u012f ka\u017ek\u0105 rodyt\u0173.</li> </ul> <p><pre><code>void swap_cpp(int&amp; x, int&amp; y) { // tampa PSEUDONIMAIS/ALIAS (int&amp; x=a, int&amp; y=b)\n    int temp = x;\n    x = y;        // Kei\u010dia pat\u012f \"original\u0105\" a\n    y = temp;     // Kei\u010dia pat\u012f \"original\u0105\" b\n}\nint main() {\n  int a=1, b=2;\n  swap_cpp(a, b);  // Atrodo paprastai!\n  /* a=2, b=1 */\n}\n</code></pre> \ud83d\udc49 Python Tutor</p>"},{"location":"Paskaitos/01/Parameters_Passing/#apibendrinimas-3-budai","title":"Apibendrinimas: 3 b\u016bdai","text":"Savyb\u0117 By Value (C/C++) Pointer (C stilius) Reference (C++ stilius) Deklaracija <code>void f(int x)</code> <code>void f(int* x)</code> <code>void f(int&amp; x)</code> Kvietimas <code>f(a)</code> <code>f(&amp;a)</code> <code>f(a)</code> Veiksmas Dirba su kopija Dirba su adresu Dirba su originalu Sintaks\u0117 Paprasta Sud\u0117tinga (<code>*</code>, <code>&amp;</code>) Paprasta Verdiktas Saugus, bet \"lokalus\" Galingas, bet pavojingas Modernus standartas <p>Tik C++ leid\u017eia ra\u0161yti taip \"\u0161variai\"</p> <pre><code>int main() {\n    int a=1, b=2;\n    swap_cpp(a, b); \n    // a=2, b=1\n}\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/","title":"Stack ADT Evoliucija C++ kalboje","text":""},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#ii-dalis-nuo-c-struct-iki-c-class","title":"II dalis: Nuo C <code>struct</code> iki C++ <code>class</code>:","text":""},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#klases-kaip-vartootojo-apibrezto-duomenu-tipo-vdt-anatomija","title":"Klas\u0117s, kaip vartootojo apibr\u0117\u017eto duomen\u0173 tipo (VDT), \"anatomija\"","text":"<p>T\u0119sinys po: I dalies 9 etap\u0173 Vartotojo tipo <code>struct</code> apibr\u0117\u017eimas modulyje (<code>.c</code>+<code>.h</code>) Tikslas: Atrasti/suvokti C++ klas\u0119 <code>class</code> kaip naujos kartos <code>struct</code> Metodologija: Tas pats principas \u2013 bandymai ir klaidos yra mokymo(si) \u012frankis!</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#ka-turime-posu-c","title":"\ud83d\udd01 K\u0105 turime po/su C?","text":"<p>I dalis: Pasiek\u0117me piln\u0105 C ADT (09 etapas)</p> <ul> <li>\u2705 Information hiding (<code>static</code> nariai, opaque pointer/forward declaration)</li> <li>\u2705 Encapsulation (duomenys + funkcijos \u2192 modulyje)</li> <li>\u2705 Multiple instances (naudojant <code>struct</code> kintam\u0173j\u0173 adresus (rodykles) <code>*pst1</code>, <code>*pst2</code>, ...)</li> <li>\u2705 Lifecycle management (\"rankiniai\" <code>create()</code> \u2192 <code>destroy()</code>)</li> </ul> <p>Bet C kalboje liko nei\u0161spr\u0119st\u0173 problem\u0173...</p> <ul> <li>Manual lifecycle: programuotojas privalo prisiminti <code>destroy()</code> \u2013 u\u017emir\u0161tus memory leak</li> <li>No operator overloading: neturime nat\u016bralaus priskyrimo/kopijavimo <code>pst1 = pst2;</code></li> <li>Opaque pointer/Forward declaration biurokratija: <code>create()</code>/<code>destroy()</code> \u2013 rankinis darbas, kur\u012f gal\u0117t\u0173 automatizuoti kompiliatorius</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#kaip-atrodo-suolis-c-struct-c-class","title":"\ud83d\ude80 Kaip atrodo \u0160uolis: C <code>struct</code> \u2192 C++ <code>class</code>","text":"<pre><code>// C (09 etapas) \u2013 rankinis valdymas\nstruct Stack *s = create(); // rankinis create()\npush(s, 'C');               // C funkcijos i\u0161kvietimo sintaks\u0117: funkcija(objektas, ...)\nchar c = pop(s);            // C objektas paprastai perduodamas rodykle=adresu\ndestroy(s);                 // \u2190 REIKIA PRISIMINTI!\n</code></pre> <pre><code>// C++ \u2013 automatinis valdymas\nStack s;               // konstruktorius = automatinis create()\ns.push('C');           // metodo sintaks\u0117: objektas.funkcija(...)\nchar c = s.pop();\n..}                    // destruktorius = automatinis destroy()\n</code></pre> <p>Paradigminis pokytis</p> <p>C: (i\u0161orin\u0117s/nesavos/globalios) funkcijos valdo objekt\u0105 \u2192 <code>push(s, 'C')</code> C++: objektas turi (savas) funkcijas \u2192 <code>s.push('C')</code> </p> <p>Tai ne tik sintaks\u0117s skirtumas \u2013 tai kitoks m\u0105stymo b\u016bdas apie kod\u0105.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#ii-dalies-kelias","title":"\ud83d\uddfa\ufe0f II dalies kelias","text":"Nr Etapas \u017dingsniai Esm\u0117 11 Discovering_CPP_Struct <code>00</code> \u2192 <code>01_NC_Naive</code> NC: <code>main()</code> nebemato funkcij\u0173 globaliai 12 ENCAPSULATING_in_CPP_Struct <code>01_OK</code> \u2192 <code>02_OK_Attack</code> <code>this</code> gimimas; <code>struct</code> dar atviras 13 HIDING_in_CLASS <code>01_NC_Naive</code> \u2192 <code>02_OK</code> \u2192 <code>03_NC_Attack</code> Paradigminis switch: kompiliatorius saugo! 14 CONSTRUCTORS_and_DESTRUCTORS <code>00</code> \u2192 <code>01_OK</code> K\u016brimas = inicializavimas \u2192 automatinis; naikinimas \u2192 automatinis 15 OVERLOADING_CONSTRUCTORS <code>00</code> \u2192 <code>01_OK</code> Overloading: tas pats vardas, skirtingi parametrai 16 Defining_METHODS_OUTSIDE <code>00</code> \u2192 <code>01_NC_Naive</code> \u2192 <code>02_OK</code> \u2192 <code>03_OK</code> <code>Stack::</code> + <code>.h</code>/<code>.cpp</code> moduliavimas"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#11-etapas-11_discovering_cpp_struct","title":"1\ufe0f\u20e31\ufe0f\u20e3 Etapas: <code>11_Discovering_CPP_Struct</code>","text":"<p><code>11_Discovering_CPP_Struct</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Suprasti, kas nutinka kai C funkcij\u0173 apibr\u0117\u017eimus perkeliame \u012f <code>struct {}</code> blok\u0105 \u2013 ir <code>main()</code> jas vis dar kvie\u010dia C stiliumi.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#0-zingsnis-referentinis-taskas-00","title":"0 \u017eingsnis: Referentinis ta\u0161kas \u2192 <code>00</code>","text":"<p>Failas: <code>11_Discovering_CPP_Struct/00/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>Pradedame nuo to paties kodo kaip <code>05/03_OK/usestack.c</code> \u2013 tik pl\u0117tinys <code>.cpp</code>. Funkcijos yra i\u0161or\u0117je <code>struct {}</code>. Tai veikia \u2013 ir C, ir C++ atveju.</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 C stilius, funkcijos i\u0161or\u0117je <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nstatic void reset(struct Stack *pst) { pst-&gt;top = 0; }\nvoid init(struct Stack *pst)         { pst-&gt;top = 0; }\nint isEmpty(struct Stack *pst)       { return 0 == pst-&gt;top; }\nint isFull(struct Stack *pst)        { return SIZE == pst-&gt;top; }\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) pst-&gt;stack[pst-&gt;top++] = c;\n}\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) return pst-&gt;stack[--pst-&gt;top];\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n    struct Stack st1, st2;\n    init(&amp;st1);\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80 <pre><code>clang++ usestack.cpp -o app   # \u2705\n./app\n</code></pre> <p>\u2705 Veikia \u2013 kaip ir C atveju. Tai m\u016bs\u0173 atspirties ta\u0161kas.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#1-zingsnis-funkcijos-i-struct-vidu-main-nepakeistas-01_nc_naive","title":"1 \u017eingsnis: Funkcijos \u012f <code>struct</code> vid\u0173, <code>main()</code> nepakeistas \u2192 <code>01_NC_Naive</code>","text":"<p>Failas: <code>11_Discovering_CPP_Struct/01_NC_Naive/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201ePerkeliu funkcij\u0173 apibr\u0117\u017eimus \u012f <code>struct Stack {}</code> vid\u0173. <code>main()</code> lieka nepakeistas \u2013 tur\u0117t\u0173 vis tiek veikti, ne?\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 funkcijos viduje, <code>main()</code> C stiliumi <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\nstruct Stack {\n    char stack[SIZE];\n    int top;\nstatic void reset(struct Stack *pst) { pst-&gt;top = 0; }\nvoid init(struct Stack *pst)         { pst-&gt;top = 0; }\nint isEmpty(struct Stack *pst)       { return 0 == pst-&gt;top; }\nint isFull(struct Stack *pst)        { return SIZE == pst-&gt;top; }\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) pst-&gt;stack[pst-&gt;top++] = c;\n}\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) return pst-&gt;stack[--pst-&gt;top];\n    return '\\0';\n}\n};\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n    struct Stack st1, st2;\n    init(&amp;st1);\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 Kompiliavimas\ud83d\udca5 Klaidos <pre><code>clang++ usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp:22:5: error: use of undeclared identifier 'init'; did you mean 'int'?\nusestack.cpp:23:15: error: use of undeclared identifier 'isFull'\nusestack.cpp:23:60: error: use of undeclared identifier 'push'\nusestack.cpp:24:13: error: use of undeclared identifier 'isEmpty'\nusestack.cpp:24:36: error: use of undeclared identifier 'pop'\n... (10 klaid\u0173 i\u0161 viso)\n</code></pre> <p>\ud83e\udd14 Funkcijos yra faile \u2013 kod\u0117l kompiliatorius j\u0173 nemato?!</p> Pam\u0105stykite prie\u0161 skaitant toliau... <p><code>init</code>, <code>push</code>, <code>pop</code> ir kt. yra apibr\u0117\u017etos \u2013 tik viduje <code>struct Stack {}</code>. <code>main()</code> jas kvie\u010dia kaip globalias: <code>init(&amp;st1)</code>. Kas pasikeit\u0117, kai funkcijos \u201epersik\u0117l\u0117\" \u012f vid\u0173?</p> <p>Atsakymas: funkcija \u201epersik\u0117l\u0117\" \u2013 ir i\u0161nyko i\u0161 globalios erdv\u0117s</p> <p>Kai funkcija yra viduje <code>struct Stack {}</code>, ji neb\u0117ra globali funkcija. Ji tapo (u\u017eb\u0117gant \u012f priek\u012f) klas\u0117s nariu \u2013 ir dabar priklauso <code>Stack</code> vard\u0173 erdvei.</p> <p><code>main()</code> ie\u0161ko <code>init</code> globaliai \u2013 ir neranda. Kompiliatorius pasi\u016blo: \u201edid you mean 'int'?\" \u2013 nes globaliai \u017eino tik <code>int</code>, ne <code>init</code>.</p> <p>Taisymas akivaizdus: kviesti per objekt\u0105 \u2013 <code>st1.init(...)</code>.</p> Beje: <code>static reset</code> nekelia klaidos... <p><code>static void reset(...)</code> viduje <code>struct</code> kompiliatorius priima be skundo. <code>static</code> klas\u0117s viduje rei\u0161kia visai k\u0105 kit\u0105 nei C kalboje \u2013 tai klas\u0117s lygio narys, ne egzemplioriaus. Prie \u0161io <code>static</code> gr\u012f\u0161ime v\u0117liau.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#2-zingsnis-main-pakeiciamas-i-objekto-sintakse-02_ok_wrong","title":"2 \u017eingsnis: <code>main()</code> pakei\u010diamas \u012f objekto sintaks\u0119 \u2192 <code>02_OK_Wrong</code>","text":"<p>Failas: <code>11_Discovering_CPP_Struct/02_OK_Wrong/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eJei funkcijos priklauso <code>Stack</code> \u2013 kviesiu jas per objekt\u0105: <code>st1.init(...)</code>.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 tik <code>main()</code> pakeistas <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\n    struct Stack {\n        char stack[SIZE];\n        int top;\n        static void reset(struct Stack *pst) { pst-&gt;top = 0; }\n        void init(struct Stack *pst)         { pst-&gt;top = 0; }\n        int isEmpty(struct Stack *pst)       { return 0 == pst-&gt;top; }\n        int isFull(struct Stack *pst)        { return SIZE == pst-&gt;top; }\n        void push(struct Stack *pst, char c) {\n            if (!isFull(pst)) pst-&gt;stack[pst-&gt;top++] = c;\n        }\n        char pop(struct Stack *pst) {\n            if (!isEmpty(pst)) return pst-&gt;stack[--pst-&gt;top];\n            return '\\0';\n        }\n    };\n// ===&gt; user dalis\n    int main(void) {\n        char c;\n        struct Stack st1, st2;\n        st1.init(&amp;st1);   // \u2190 objekto sintaks\u0117\n        while ((!st1.isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(&amp;st1, c);\n        while (!st1.isEmpty(&amp;st1)) putchar(st1.pop(&amp;st1));\n        putchar('\\n');\n        st2.init(&amp;st2);\n        while ((!st2.isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(&amp;st2, c);\n        while (!st2.isEmpty(&amp;st2)) putchar(st2.pop(&amp;st2));\n        putchar('\\n');\n        return 0;\n    }\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang++ usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\ndlrow\n</code></pre> <p>\u2705 Veikia!</p> <p>Bet... <code>st1.init(&amp;st1)</code> \u2013 ar tai normalu?</p> <p>Veikia \u2013 bet atrodo keistai. Kvie\u010diame per objekt\u0105 <code>st1</code>, ir dar atskirai perduodame <code>&amp;st1</code> kaip parametr\u0105. Objektas perduodamas du kartus: vien\u0105 kart\u0105 kaip kviet\u0117jas, antr\u0105 kart\u0105 kaip argumentas.</p> <p>Tai yra kitas \u017eingsnis: kaip i\u0161mesti <code>struct Stack *pst</code> parametr\u0105 \u2013 ir leisti C++ tai tvarkyti automati\u0161kai.</p> <p></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#12-etapas-12_encapsulating_in_cpp_struct","title":"1\ufe0f\u20e32\ufe0f\u20e3 Etapas: <code>12_ENCAPSULATING_in_CPP_Struct</code>","text":"<p><code>12_ENCAPSULATING_in_CPP_Struct</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mesti <code>struct Stack *pst</code> parametr\u0105 \u2013 suprasti <code>this</code>. Ir pamatyti, kad <code>struct</code> su metodais dar nesuteikia information hiding.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#1-zingsnis-ismetame-pst-parametra-01_ok","title":"1 \u017eingsnis: I\u0161metame <code>pst</code> parametr\u0105 \u2192 <code>01_OK</code>","text":"<p>Failas: <code>12_ENCAPSULATING_in_CPP_Struct/01_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\"<code>st1.init(&amp;st1)</code> \u2013 absurdas. Objektas jau \u017eino, kas jis yra \u2013 i\u0161meskime <code>&amp;st1</code> kaip parametr\u0105!\"</p> \ud83d\udcc4 <code>usestack.cpp</code> <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\n    struct Stack {\n        char stack[SIZE];\n        int top;\n\n        void init()       { top = 0; }            // \u2190 pst - i\u0161mestas, top - tiesiogiai\n        void reset()       { this-&gt;top = 0; }     // `this` - rodo \u012f \"save\"\n        int isEmpty()     { return 0 == top; }\n        int isFull()      { return SIZE == top; }\n        void push(char c) {\n            if (!isFull()) stack[top++] = c;       // \u2190 stack, top \u2013 tiesiogiai\n        }\n        char pop() {\n            if (!isEmpty()) return stack[--top];\n            return '\\0';\n        }\n    };\n// ===&gt; user dalis\n    int main(void) {\n        char c;\n        struct Stack st1;\n        Stack st2;  // \"nebetampome\" etik\u0117t\u0117s `struct`\n        st1.init(); // \u2190 neb\u0117ra (&amp;st) !\n        while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n        while (!st1.isEmpty()) putchar(st1.pop());\n        putchar('\\n');\n        st2.init();\n        while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n        while (!st2.isEmpty()) putchar(st2.pop());\n        putchar('\\n');\n        return 0;\n    }\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang++ usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\ndlrow\n</code></pre> <p>\u2705 Veikia!</p> <p>Kas nutiko su <code>pst</code>?</p> <p>Prie\u0161 (11 \u2013 dar su <code>pst</code>): <pre><code>void init(struct Stack *pst) { pst-&gt;top = 0; }\nst1.init(&amp;st1);   // \u2190 objektas du kartus \u2013 absurdas\n</code></pre> Po (12 \u2013 be <code>pst</code>): <pre><code>void init() { top = 0; }\nst1.init();        // \u2190 \u0161varu\n</code></pre> Kompiliatorius automati\u0161kai perduoda rodykl\u0119 \u012f kvie\u010diant\u012f objekt\u0105. Ta pasl\u0117pta rodykl\u0117 vadinamas <code>this</code>.</p> Kas yra <code>this</code>? <p><pre><code>// Tai k\u0105 mes ra\u0161ome:\nvoid init() { top = 0; }\n\n// Tai k\u0105 kompiliatorius \u201emato\" po gaubtu:\nvoid init(Stack* const this) { this-&gt;top = 0; }\n</code></pre> Kai ra\u0161ome <code>st1.init()</code> \u2013 kompiliatorius i\u0161ver\u010dia \u012f <code>Stack::init(&amp;st1)</code>. <code>this</code> visada rodo \u012f t\u0105 objekt\u0105, kuris kviet\u0117 metod\u0105.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#2-zingsnis-ataka-vis-dar-pavyksta-02_ok_attack","title":"2 \u017eingsnis: Ataka vis dar pavyksta \u2192 <code>02_OK_Attack</code>","text":"<p>Failas: <code>12_ENCAPSULATING_in_CPP_Struct/02_OK_Attack/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eTurime <code>struct</code> su metodais \u2013 ar duomenys dabar saug\u016bs?\"</p> \ud83d\udcc4 Atakos kodas <code>main()</code> dalyje <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\n    struct Stack {\n        char stack[SIZE];\n        int top;\n\n        void init()       { top = 0; }            // \u2190 pst - i\u0161mestas, top - tiesiogiai\n        int isEmpty()     { return 0 == top; }\n        int isFull()      { return SIZE == top; }\n        void push(char c) {\n            if (!isFull()) stack[top++] = c;       // \u2190 stack, top \u2013 tiesiogiai\n        }\n        char pop() {\n            if (!isEmpty()) return stack[--top];\n            return '\\0';\n        }\n    };\n// ===&gt; user dalis\n    int main(void) {\n        char c;\n        struct Stack st1;\n        Stack st2;  // \"nebetampome\" etik\u0117t\u0117s 'struct'\n        st1.init(); // \u2190 neb\u0117ra (&amp;st) !\n        while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n        while (!st1.isEmpty()) putchar(st1.pop());\n        putchar('\\n');\n        st2.init();\n        while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n        while (!st2.isEmpty()) putchar(st2.pop());\n        putchar('\\n');\n        return 0;\n    }\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang++ usestack.cpp -o app   # \u2705 kompiliuoja!\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\n!dlrow   \u2190 '!' \u012fterptas \u2013 ataka pavyko!\n</code></pre> <p>\u2705 Kompiliuoja. \u2705 Veikia. \u274c Ataka pavyko!</p> <p><code>struct Stack</code> nariai yra vie\u0161i \u2013 bet kuris kodas gali juos tiesiogiai keisti. Metodai viduje \u2013 tai encapsulation. Bet duomenys atviri \u2013 ne information hiding.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#terminu-painiava-encapsulation-vs-information-hiding","title":"\ud83d\udccc Termin\u0173 painiava: Encapsulation vs Information Hiding","text":"<p>Dvi skirtingos s\u0105vokos \u2013 da\u017enai supainiojamos</p> <p>Encapsulation \u2013 duomen\u0173 ir operacij\u0173 suvienijimas \u012f vien\u0105 vienet\u0105: <pre><code>struct Stack {\n    char stack[SIZE];  // duomenys\n    int top;\n    void push(char c); // operacijos kartu!\n    char pop();\n};\n</code></pre> \u2705 Pasiekta jau 12 etape \u2013 <code>struct</code> su metodais.</p> <p>Information Hiding \u2013 vidin\u0117s strukt\u016bros pasl\u0117pimas nuo vartotojo: <pre><code>class Stack {\nprivate:\n    char stack[SIZE];  // \u2190 nematoma i\u0161 i\u0161or\u0117s\n    int top;\npublic:\n    void push(char c);\n    char pop();\n};\n</code></pre> \u2705 Pasiekta 13 etape \u2013 <code>class</code> su <code>private:</code>.</p> <p>Encapsulation \u2260 Information Hiding</p> Encapsulation Information Hiding C analogas 06 etapas (<code>struct</code> modulyje) 07\u201309 etapai (opaque pointer) C++ analogas 12 etapas (<code>struct</code> su metodais) 13 etapas (<code>class</code> + <code>private:</code>) Kas kartu? Duomenys + funkcijos Taip pat + duomenys pasl\u0117pti Ataka \u2705 Pavyksta \u274c NC \u2013 kompiliatorius blokuoja <p>Encapsulation yra b\u016btina s\u0105lyga, bet nepakankama information hiding pasiekti.</p> <p></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#13-etapas-13_hiding_in_class","title":"1\ufe0f\u20e33\ufe0f\u20e3 Etapas: <code>13_HIDING_in_CLASS</code>","text":"<p><code>13_HIDING_in_CLASS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Suprasti, kuo <code>class</code> skiriasi nuo <code>struct</code> \u2013 ir kod\u0117l tai yra paradigminis pokytis.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#1-zingsnis-plikas-class-be-specifikatoriu-01_nc_naive","title":"1 \u017eingsnis: Plikas <code>class</code> be specifikatori\u0173 \u2192 <code>01_NC_Naive</code>","text":"<p>Failas: <code>13_HIDING_in_CLASS/01_NC_Naive/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eC++ turi special\u0173 rakta\u017eod\u012f objektams \u2013 <code>class</code>. Pakei\u010diu <code>struct</code> \u012f <code>class</code> ir viskas tur\u0117t\u0173 veikti kaip anks\u010diau.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 tik <code>struct</code> \u2192 <code>class</code> <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\n    class Stack {   // CLASS !\n        char stack[SIZE];\n        int top;\n\n        void init()       { top = 0; }       \n        int isEmpty()     { return 0 == top; }\n        int isFull()      { return SIZE == top; }\n        void push(char c) {\n            if (!isFull()) stack[top++] = c;\n        }\n        char pop() {\n            if (!isEmpty()) return stack[--top];\n            return '\\0';\n        }\n    };\n// ===&gt; user dalis\n    int main(void) {\n        char c;\n        Stack st1, st2; // \"nebetampome\" \u017eodeli\u0173 'struct' ar 'class'\n        st1.init(); \n        while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n        while (!st1.isEmpty()) putchar(st1.pop());\n        putchar('\\n');\n        st2.init();\n        while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n        while (!st2.isEmpty()) putchar(st2.pop());\n        putchar('\\n');\n        return 0;\n    }\n</code></pre> \ud83d\udd28 g++ kompiliavimas\ud83d\udca5 g++ klaidos\ud83d\udd28 clang kompiliavimas\ud83d\udca5 clang klaidos <pre><code>g++ usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp: In function 'int main()':\nusestack.cpp:23:17: error: 'void Stack::init()' is private within this context\n   23 |         st1.init();\n      |         ~~~~~~~~^~\nusestack.cpp:8:14: note: declared private here\n    8 |         void init()       { top = 0; }\n      |              ^~~~\nusestack.cpp:24:28: error: 'int Stack::isFull()' is private within this context\n... (10 klaid\u0173 i\u0161 viso)\n</code></pre> <pre><code>clang++ usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp:23:13: error: 'init' is a private member of 'Stack'\n   23 |         st1.init();\n      |             ^\nusestack.cpp:8:14: note: implicitly declared private here\n    8 |         void init()       { top = 0; }\n      |              ^\n... (10 klaid\u0173 i\u0161 viso)\n</code></pre> <p>\ud83e\udd14 Pakeit\u0117me tik vien\u0105 \u017eod\u012f \u2013 <code>struct</code> \u2192 <code>class</code>. Kod\u0117l 10 klaid\u0173?</p> Pam\u0105stykite prie\u0161 skaitant toliau... <p><code>struct Stack</code> veik\u0117, <code>class Stack</code> \u2013 ne. Koks formalus skirtumas tarp j\u0173 C++ kalboje?</p> <p>Atsakymas: <code>class</code> pagal nutyl\u0117jim\u0105 slepia visk\u0105</p> <code>struct</code> <code>class</code> Nariai pagal nutyl\u0117jim\u0105 <code>public</code> <code>private</code> <p>Tai vienintelis formalus skirtumas. Bet jo pasekm\u0117 mil\u017eini\u0161ka:</p> <p>Plikas <code>class Stack { void init() {...} }</code> \u2013 <code>init</code> automati\u0161kai <code>private</code>. <code>main()</code> bando kviesti <code>private</code> metod\u0105 \u2013 kompiliatorius blokuoja.</p> <p>Atkreipkite d\u0117mes\u012f \u012f clang \u017einut\u0119: <code>implicitly declared private here</code> \u2013 ne mes para\u0161\u0117me <code>private:</code>, kompiliatorius tai padar\u0117 automati\u0161kai.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#2-zingsnis-pridedame-public-02_ok","title":"2 \u017eingsnis: Pridedame <code>public:</code> \u2192 <code>02_OK</code>","text":"<p>Failas: <code>13_HIDING_in_CLASS/02_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eMetodai turi b\u016bti pasiekiami i\u0161 i\u0161or\u0117s \u2013 dedu <code>public:</code>. Duomenys tegul lieka <code>private:</code>.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 su <code>public:</code>/<code>private:</code> <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\n    class Stack {   // CLASS !\n    private:        // pagal nutyl\u0117jim\u0105 - viskas buvo private:\n        char stack[SIZE];\n        int top;\n    public:\n        void init()       { top = 0; }       \n        int isEmpty()     { return 0 == top; }\n        int isFull()      { return SIZE == top; }\n        void push(char c) {\n            if (!isFull()) stack[top++] = c;\n        }\n        char pop() {\n            if (!isEmpty()) return stack[--top];\n            return '\\0';\n        }\n    };\n// ===&gt; user dalis\n    int main(void) {\n        char c;\n        Stack st1, st2;\n        st1.init(); // \u2190 neb\u0117ra (&amp;st) !\n        while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n        while (!st1.isEmpty()) putchar(st1.pop());\n        putchar('\\n');\n        st2.init();\n        while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n        while (!st2.isEmpty()) putchar(st2.pop());\n        putchar('\\n');\n        return 0;\n    }\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang++ usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\ndlrow\n</code></pre> <p>\u2705 Veikia!</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#3-zingsnis-ataka-03_nc_attack","title":"3 \u017eingsnis: Ataka \u2192 <code>03_NC_Attack</code>","text":"<p>Failas: <code>13_HIDING_in_CLASS/03_NC_Attack/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eI dalyje su C <code>struct</code> ataka pavyko (06 etapas). Patikriname ar \u010dia tas pats...\"</p> \ud83d\udcc4 Atakos kodas <code>main()</code> dalyje <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\n    class Stack {   // CLASS !\n    private:        // pagal nutyl\u0117jim\u0105 - viskas buvo private:\n        char stack[SIZE];\n        int top;\n    public:\n        void init()       { top = 0; }       \n        int isEmpty()     { return 0 == top; }\n        int isFull()      { return SIZE == top; }\n        void push(char c) {\n            if (!isFull()) stack[top++] = c;\n        }\n        char pop() {\n            if (!isEmpty()) return stack[--top];\n            return '\\0';\n        }\n    };\n// ===&gt; user dalis\n    int main(void) {\n        char c;\n        Stack st1, st2;\n        st1.init(); // \u2190 neb\u0117ra (&amp;st) !\n        while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n        while (!st1.isEmpty()) putchar(st1.pop());\n        putchar('\\n');\n        st2.init();\n        while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n\n        while (!st2.isEmpty()) putchar(st2.pop());\n        putchar('\\n');\n        return 0;\n    }\n</code></pre> \ud83d\udd28 Kompiliavimas\ud83d\udca5 Klaidos <pre><code>clang++ usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp:XX:X: error: 'stack' is a private member of 'Stack'\nusestack.cpp:XX:X: error: 'top' is a private member of 'Stack'\n2 errors generated.\n</code></pre> <p>\u2705 Ataka nepavyko! Kompiliatorius saugo!</p> <p>Paradigminis pokytis \u2013 lyginimas su C</p> C (06 etapas \u2013 <code>struct</code> modulyje) C++ (13 etapas \u2013 <code>class</code>) Ataka \u2705 Pavyko \u2013 <code>st.top = 999;</code> veikia \u274c NC \u2013 kompiliatorius blokuoja Kas saugo? Niekas \u2013 programuotojo atsakomyb\u0117 Kompiliatorius C (07-09 \u2013 opaque pointer) \u2705 Nepavyko \u2013 bet reikia atskiro <code>.c</code> failo Viename faile! Kiek fail\u0173? <code>stack.h</code> + <code>stack.c</code> + <code>user.c</code> Galima viename faile Refleksija: kas dar liko? <p>Turime <code>class</code> su <code>private:</code>/<code>public:</code> \u2013 tai did\u017eiulis \u017eingsnis! Bet <code>init()</code> vis dar kvie\u010diamas rankiniu b\u016bdu \u2013 ar gal\u0117t\u0173 objektas pats pasir\u016bpinti savo inicializacija?</p> <p>\u2192 14 etapas: Konstruktorius \u2013 automatinis <code>init()</code>! \ud83d\ude80</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#ii-dalies-santrauka-1113-etapai","title":"\ud83c\udfaf II dalies santrauka (11\u201313 etapai)","text":"Nr Etapas \u017dingsniai Atradimas 11 Discovering_CPP_Struct <code>00</code> OK \u2192 <code>01_NC_Naive</code> Funkcija klas\u0117s viduje \u2260 globali funkcija 12 ENCAPSULATING_in_CPP_Struct <code>01_OK</code> \u2192 <code>02_OK_Attack</code> <code>this</code> + encapsulation \u2260 information hiding 13 HIDING_in_CLASS <code>01_NC_Naive</code> \u2192 <code>02_OK</code> \u2192 <code>03_NC_Attack</code> <code>class</code> = <code>private</code> pagal nutyl\u0117jim\u0105; kompiliatorius saugo <p>Klas\u0117s anatomija \u2013 apibendrinimas</p> <pre><code>class Stack {\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nprivate:              // \u2190 prieigos specifikatorius\n    char stack[5];    // \u2190 duomen\u0173 nariai (data members)\n    int top;          //   pasl\u0117pti nuo i\u0161or\u0117s\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npublic:               // \u2190 prieigos specifikatorius\n    void init();      // \u2190 funkcij\u0173 nariai (member functions / metodai)\n    void push(char c);//   prieinami i\u0161 i\u0161or\u0117s\n    char pop();\n    int isEmpty();\n    int isFull();\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n};   // \u2190 kabliata\u0161kis! (skirtingai nuo funkcij\u0173 blok\u0173)\n</code></pre> <p><code>struct</code> vs <code>class</code> C++ kalboje \u2013 formalus skirtumas vienas:</p> Nariai pagal nutyl\u0117jim\u0105 <code>struct</code> <code>public</code> <code>class</code> <code>private</code> <p>Kitas \u017eingsnis: Konstruktorius ir destruktorius \u2013 automatinis lifecycle! \ud83d\ude80</p> <p></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#14-etapas-14_constructors_and_destructors","title":"1\ufe0f\u20e34\ufe0f\u20e3 Etapas: <code>14_CONSTRUCTORS_and_DESTRUCTORS</code>","text":"<p><code>14_CONSTRUCTORS_and_DESTRUCTORS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Suprasti, kad k\u016brimo momentas yra garantuotas inicializavimo ta\u0161kas \u2013 tai ne taisykl\u0117 kuri\u0105 reikia prisiminti, o kalbos mechanizmas. Ir kad naikinimo momentas taip pat garantuotas \u2013 automati\u0161kai.</p> <p>\ud83d\udccc Atsisveikinimas su <code>getchar()</code>/<code>putchar()</code></p> <p>C++ pilnai palaiko C bibliotek\u0105 \u2013 <code>getchar()</code>/<code>putchar()</code> veik\u0117 ir veiks. Bet nuo \u0161iol naudosime <code>cin</code>/<code>cout</code> \u2013 C++ standartin\u0117s \u012fvesties/i\u0161vesties srautus.</p> <p>Beje: <code>cin.get(c)</code>, o ne <code>cin &gt;&gt; c</code> \u2013 nes <code>&gt;&gt;</code> praleist\u0173 tarpelius. Ir pasteb\u0117kite: <code>cin.get(c)</code> \u2013 metodas ant objekto, lygiai kaip <code>s.push(c)</code>. <code>cin</code> ir <code>cout</code> \u2013 tai objektai! Tik \u0161ito mokykloje niekas nepasak\u0117 \ud83d\ude42</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#0-zingsnis-bazinis-kodas-veikia-atsitiktinai-00","title":"0 \u017eingsnis: Bazinis kodas \u2013 veikia atsitiktinai \u2192 <code>00</code>","text":"<p>Failas: <code>14_CONSTRUCTORS_and_DESTRUCTORS/00/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>Minimizuotas bazinis kodas \u2013 vienas objektas, <code>bool</code>, be <code>init()</code>. Ar veiks?</p> \ud83d\udcc4 <code>usestack.cpp</code> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n// ===&gt; stack dalis\n#define SIZE 5\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    bool isEmpty() { return 0 == top; }\n    bool isFull()  { return SIZE == top; }\n    void push(char c) {\n        if (!isFull()) stack[top++] = c;\n    }\n    char pop() {\n        if (!isEmpty()) return stack[--top];\n        return '\\0';\n    }\n};\n// ===&gt; user dalis\nint main(void) {\n    char c;\n    Stack s;\n    while (!s.isFull() &amp;&amp; cin.get(c) &amp;&amp; c != '\\n')\n        s.push(c);\n    while (!s.isEmpty())\n        cout &lt;&lt; s.pop();\n    cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80 <pre><code>clang++ usestack.cpp -o app   # \u2705 kompiliuoja!\n./app\n</code></pre> <p>\u26a0\ufe0f Kompiliuoja. Kartais veikia. Kartais \u2013 ne.</p> <p><code>top</code> nario reik\u0161m\u0117 n\u0117ra inicializuota \u2013 joje yra kas tik atsitiko b\u016bti atmintyje. Da\u017enai b\u016bna <code>0</code> (stack atmintis da\u017enai nulinata) \u2013 tod\u0117l \u201epasiseka\". Bet tai atsitiktinumas, ne teisingumas.</p> <p>C++ garantuoja k\u016brimo moment\u0105 \u2013 bet ne inicializavim\u0105 (be konstruktoriaus)</p> <p>Kompiliatorius automati\u0161kai generuoja vadinam\u0105j\u012f trivial default constructor \u2013 jis sukuria objekt\u0105, bet nieko nedaro su nari\u0173 reik\u0161m\u0117mis.  </p> <p>Tai tarsi <code>create()</code> i\u0161 C 08 etapo \u2013 be <code>top = 0</code> viduje.</p> Pam\u0105stykite: kas i\u0161 tikr\u0173j\u0173 garantuoja inicializavim\u0105? <p>Ne programuotojo disciplina (<code>init()</code> kvietimas). Ne atsitiktinumas (atmintis \u201epasisek\u0117\" b\u016bti nulinata).  </p> <p>Konstruktorius \u2013 k\u016brimo ir inicializavimo momentas sutampa.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#1-zingsnis-default-konstruktorius-destruktorius-01_ok","title":"1 \u017eingsnis: Default konstruktorius + destruktorius \u2192 <code>01_OK</code>","text":"<p>Failas: <code>14_CONSTRUCTORS_and_DESTRUCTORS/01_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eNoriu, kad objektas pats pasir\u016bpint\u0173 savo inicializacija k\u016brimo metu \u2013 ir prane\u0161tu apie save gyvavimo prad\u017eioje ir pabaigoje.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n// ===&gt; stack dalis\n#define SIZE 5\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    Stack()  {                              // \u2190 konstruktorius: tas pats vardas kaip klas\u0117, be gr\u0105\u017einamo tipo\n        top = 0;\n        cout &lt;&lt; \"[CTOR] Stack sukurtas\\n\";\n    }\n    ~Stack() {                              // \u2190 destruktorius: ~ + klas\u0117s vardas\n        cout &lt;&lt; \"[DTOR] Stack sunaikintas\\n\";\n    }\n    bool isEmpty() { return 0 == top; }\n    bool isFull()  { return SIZE == top; }\n    void push(char c) {\n        if (!isFull()) stack[top++] = c;\n    }\n    char pop() {\n        if (!isEmpty()) return stack[--top];\n        return '\\0';\n    }\n};\n// ===&gt; user dalis\nint main(void) {\n    char c;\n    cout &lt;&lt; \"--- prie\u0161 { - scope (bloko) prad\u017ei\u0105 ---\\n\";\n    {\n        cout &lt;&lt; \"--- prie\u0161 Stack s; ---\\n\";\n        Stack s;                            // \u2190 CTOR i\u0161kvie\u010diamas \u010dia\n        while (!s.isFull() &amp;&amp; cin.get(c) &amp;&amp; c != '\\n')\n            s.push(c);\n        while (!s.isEmpty())\n            cout &lt;&lt; s.pop();\n        cout &lt;&lt; '\\n';\n        cout &lt;&lt; \"--- prie\u0161 } - scope pabaig\u0105 ---\\n\";\n    }                                       // \u2190 DTOR i\u0161kvie\u010diamas \u010dia automati\u0161kai!\n    cout &lt;&lt; \"--- po scope pabaigos ---\\n\";\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang++ usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>--- prie\u0161 Stack s ---\n[CTOR] Stack sukurtas\nhello\nolleh\n--- prie\u0161 scope pabaig\u0105 ---\n[DTOR] Stack sunaikintas\n--- po scope pabaigos ---\n</code></pre> <p>\u2705 Konstruktorius ir destruktorius veikia automati\u0161kai!</p> <p>Konstruktoriaus anatomija</p> <pre><code>Stack() { top = 0; }\n//^^^^    \u2190 tas pats vardas kaip klas\u0117\n//     \u2190 jokio gr\u0105\u017einamo tipo (net ne void!)\n</code></pre> <p>Kada kvie\u010diamas? Tiksliai tada, kai objektas sukuriamas. Kas kvie\u010dia? Kompiliatorius \u2013 automati\u0161kai. Programuotojas negali \u201eu\u017emir\u0161ti\".</p> <p>Destruktoriaus anatomija</p> <pre><code>~Stack() { cout &lt;&lt; \"[DTOR] Stack sunaikintas\\n\"; }\n//^^^^^    \u2190 tild\u0117 + klas\u0117s vardas\n</code></pre> <p>Kada kvie\u010diamas? Tiksliai tada, kai objektas baigia gyventi \u2013 scope pabaigoje. Kas kvie\u010dia? Kompiliatorius \u2013 automati\u0161kai.</p> <p>C \u2192 C++ lifecycle palyginimas</p> C (08\u201309 etapai) C++ (14 etapas) K\u016brimas <code>create()</code> \u2013 reikia kviesti <code>Stack s;</code> \u2013 konstruktorius automati\u0161kai Naikinimas <code>destroy()</code> \u2013 reikia kviesti <code>}</code> \u2013 destruktorius automati\u0161kai U\u017emir\u0161us Memory leak Ne\u012fmanoma u\u017emir\u0161ti Kas atsakingas? Programuotojas Kompiliatorius Refleksija: kam reikalingas destruktorius Stack klas\u0117je? <p>M\u016bs\u0173 <code>Stack</code> naudoja statin\u012f masyv\u0105 \u2013 atminties atlaisvinti nereikia. Destruktorius \u010dia skirtas tik demonstracijai \u2013 matome kada objektas \u201emir\u0161ta\".  </p> <p>Kai klas\u0117 naudos dinamin\u0119 atmint\u012f (<code>new</code>) \u2013 destruktorius taps b\u016btinas. \u2192 Tai Rule of Three/Five tema (v\u0117liau kurse).</p> <p></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#15-etapas-15_overloading_constructors","title":"1\ufe0f\u20e35\ufe0f\u20e3 Etapas: <code>15_OVERLOADING_CONSTRUCTORS</code>","text":"<p><code>15_OVERLOADING_CONSTRUCTORS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Atrasti overloading \u2013 t\u0105 pat\u012f vard\u0105, skirtingus parametrus. Pirmiausia per konstruktorius, nes \u010dia labiausiai nat\u016bralu: skirtingi k\u016brimo b\u016bdai \u2192 skirtingi konstruktoriai.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#0-zingsnis-bazinis-kodas-vienas-konstruktorius-00","title":"0 \u017eingsnis: Bazinis kodas \u2013 vienas konstruktorius \u2192 <code>00</code>","text":"<p>Failas: <code>15_OVERLOADING_CONSTRUCTORS/00/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>Turime default konstruktori\u0173 i\u0161 14 etapo. Bet kas jei norime sukurti stek\u0105 jau su duomenimis?</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 dar tik default konstruktorius <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#define SIZE 5\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    Stack() {\n        top = 0;\n        cout &lt;&lt; \"[CTOR] Stack sukurtas (tu\u0161\u010dias)\\n\";\n    }\n    ~Stack() {\n        cout &lt;&lt; \"[DTOR] Stack sunaikintas\\n\";\n    }\n    bool isEmpty() { return 0 == top; }\n    bool isFull()  { return SIZE == top; }\n    void push(char c) {\n        if (!isFull()) stack[top++] = c;\n    }\n    char pop() {\n        if (!isEmpty()) return stack[--top];\n        return '\\0';\n    }\n};\nint main(void) {\n    Stack s1;               // \u2190 default: tu\u0161\u010dias stekas\n    s1.push('C');\n    s1.push('+');\n    s1.push('+');\n    while (!s1.isEmpty())\n        cout &lt;&lt; s1.pop();\n    cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> \u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>[CTOR] Stack sukurtas (tu\u0161\u010dias)\nCBA\n[DTOR] Stack sunaikintas\n</code></pre> <p>Bet kas jei norime i\u0161 karto sukurti stek\u0105 su pradiniais duomenimis?</p> <p><code>s1.push('A'); s1.push('B'); s1.push('C');</code> \u2013 tris kartus kvie\u010diame <code>push()</code>. C kalboje buvo galima perduoti duomenis \u012f <code>create()</code> \u2192 ar C++ leid\u017eia perduoti \u012f konstruktori\u0173?</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#1-zingsnis-parametrinis-konstruktorius-01_ok","title":"1 \u017eingsnis: Parametrinis konstruktorius \u2192 <code>01_OK</code>","text":"<p>Failas: <code>15_OVERLOADING_CONSTRUCTORS/01_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eNoriu tur\u0117ti du k\u016brimo b\u016bdus: tu\u0161\u010di\u0105 stek\u0105 ir stek\u0105 su pradiniais duomenimis. Abu konstruktoriai vadinsis <code>Stack</code> \u2013 ar tai leis kompiliatorius?\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 du konstruktoriai <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#define SIZE 5\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    Stack()              { top = 0; }\n    Stack(const char* s) { top = 0; while (*s &amp;&amp; !isFull()) stack[top++] = *s++; }\n    ~Stack()             { }\n    bool isEmpty()       { return 0 == top; }\n    bool isFull()        { return SIZE == top; }\n    void push(char c)    { if (!isFull()) stack[top++] = c; }\n    char pop()           { if (!isEmpty()) return stack[--top]; return '\\0'; }\n};\nint main(void) {\n    Stack s1;\n    Stack s2(\"C++\");\n    s1.push('C');\n    while (!s1.isEmpty())\n        cout &lt;&lt; s1.pop();\n    cout &lt;&lt; '\\n';\n    while (!s2.isEmpty())\n        cout &lt;&lt; s2.pop();\n    cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang++ usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>[CTOR] Stack sukurtas (tu\u0161\u010dias)\n[CTOR] Stack sukurtas su duomenimis\ns1: X\ns2: EDCBA\n[DTOR] Stack sunaikintas\n[DTOR] Stack sunaikintas\n</code></pre> <p>\u2705 Du konstruktoriai \u2013 tas pats vardas <code>Stack</code>, skirtingi parametrai!</p> <p>Overloading \u2013 tas pats vardas, skirtingi parametrai</p> <p><pre><code>Stack s1;          // \u2190 Stack()            \u2013 be parametr\u0173\nStack s2(\"ABCDE\"); // \u2190 Stack(const char*) \u2013 su parametru\n</code></pre> Kompiliatorius automati\u0161kai parenka tinkam\u0105 konstruktori\u0173 pagal tai, kaip objektas kuriamas.</p> <p>Tai function overloading \u2013 ta pati s\u0105voka galioja ir paprastoms funkcijoms, ne tik konstruktoriams.</p> <p>Overloading taisykl\u0117</p> <p>Dvi funkcijos gali tur\u0117ti t\u0105 pat\u012f vard\u0105, jei skiriasi: - parametr\u0173 skai\u010dius, arba - parametr\u0173 tipai</p> <p>Gr\u0105\u017einamo tipo nepakanka atskirti \u2013 kompiliatorius j\u012f ignoruoja renkantis.</p> Destruktorius \u2013 visada vienas <p>Konstruktori\u0173 gali b\u016bti kiek nori \u2013 k\u016brimo b\u016bd\u0173 gali b\u016bti daug. Destruktorius \u2013 visada vienas: sunaikinimo b\u016bdas yra tik vienas. Tod\u0117l <code>~Stack()</code> negali tur\u0117ti parametr\u0173 ir negali b\u016bti perkrautas (overloaded).</p> Kalibracija su U2 u\u017eduotimi <p><code>Student</code> klas\u0117je taip pat yra du konstruktoriai: <pre><code>Student()                               // \u2190 default: \"Nezinomas\", 0, 0.0\nStudent(const char* v, int a, double p) // \u2190 parametrinis: konkretus studentas\n</code></pre> Tas pats overloading principas \u2013 tik skirtinga klas\u0117 ir skirtingi duomenys. Konstruktorius = <code>create()</code> su parametrais i\u0161 C 08\u201309 etap\u0173.</p> <p></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#16-etapas-16_defining_methods_outside","title":"1\ufe0f\u20e36\ufe0f\u20e3 Etapas: <code>16_Defining_METHODS_OUTSIDE</code>","text":"<p><code>16_Defining_METHODS_OUTSIDE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Suprasti, kad metod\u0173 apibr\u0117\u017eimus galima (ir da\u017enai reikia) i\u0161kelti u\u017e klas\u0117s rib\u0173 \u2013 ir kaip tai daryti su <code>Stack::</code> scope resolution operatoriumi. Tada \u2013 pa\u017e\u012fstamas \u017eingsnis: skaidymas \u012f <code>.h</code> ir <code>.cpp</code>.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#0-zingsnis-bazinis-kodas-viskas-klases-viduje-00","title":"0 \u017eingsnis: Bazinis kodas \u2013 viskas klas\u0117s viduje \u2192 <code>00</code>","text":"<p>Failas: <code>16_Defining_METHODS_OUTSIDE/00/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>Turima versija i\u0161 15 etapo \u2013 visi metodai inline klas\u0117s viduje. Veikia, bet klas\u0117 tampa didel\u0117 ir sunkiai skaitoma.</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 viskas viduje (atspirties ta\u0161kas) <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#define SIZE 5\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    Stack() {                               // \u2190 default konstruktorius\n        top = 0;\n        cout &lt;&lt; \"[CTOR] Stack sukurtas (tu\u0161\u010dias)\\n\";\n    }\n    Stack(const char* str) {               // \u2190 parametrinis konstruktorius\n        top = 0;\n        while (*str &amp;&amp; !isFull())\n            stack[top++] = *str++;\n        cout &lt;&lt; \"[CTOR] Stack sukurtas su duomenimis\\n\";\n    }\n    ~Stack() {\n        cout &lt;&lt; \"[DTOR] Stack sunaikintas\\n\";\n    }\n    bool isEmpty() { return 0 == top; }\n    bool isFull()  { return SIZE == top; }\n    void push(char c) {\n        if (!isFull()) stack[top++] = c;\n    }\n    char pop() {\n        if (!isEmpty()) return stack[--top];\n        return '\\0';\n    }\n};\nint main(void) {\n    Stack s1;               // \u2190 default konstruktorius\n    Stack s2(\"C++\");      // \u2190 parametrinis konstruktorius\n\n    cout &lt;&lt; \"s1: \";\n    s1.push('C');\n    while (!s1.isEmpty())\n        cout &lt;&lt; s1.pop();\n    cout &lt;&lt; '\\n';\n\n    cout &lt;&lt; \"s2: \";\n    while (!s2.isEmpty())\n        cout &lt;&lt; s2.pop();\n    cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Klas\u0117 auga \u2013 metod\u0173 apibr\u0117\u017eimai u\u017ego\u017eia strukt\u016br\u0105</p> <p>Kol metodai trumpi \u2013 dar gerai. Bet kai <code>push()</code>, <code>pop()</code> taps sud\u0117tingesni, klas\u0117s deklaracija ir metod\u0173 apibr\u0117\u017eimai susipins \u012f vien\u0105 kr\u016bv\u0105. C kalboje \u0161i\u0105 problem\u0105 sprend\u0117me <code>.h</code> + <code>.c</code> skaidymu \u2013 C++ turi t\u0105 pat\u012f sprendim\u0105.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#1-zingsnis-metodai-isoreje-be-stack-01_nc_naive","title":"1 \u017eingsnis: Metodai i\u0161or\u0117je be <code>Stack::</code> \u2192 <code>01_NC_Naive</code>","text":"<p>Failas: <code>16_Defining_METHODS_OUTSIDE/01_NC_Naive/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eI\u0161trauksiu metod\u0173 apibr\u0117\u017eimus i\u0161 klas\u0117s \u2013 kaip C kalboje funkcijas i\u0161 <code>struct {}</code> bloko.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 metodai i\u0161or\u0117je, bet be <code>Stack::</code> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#define SIZE 5\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    Stack();\n    Stack(const char* str);\n    ~Stack();\n    bool isEmpty();\n    bool isFull();\n    void push(char c);\n    char pop();\n};\n\nStack()              { top = 0; }                   // \u2190 be Stack::\nStack(const char* s) { top = 0; while (*s &amp;&amp; !isFull()) stack[top++] = *s++; }\nbool isEmpty()       { return 0 == top; }\nbool isFull()        { return SIZE == top; }\nvoid push(char c)    { if (!isFull()) stack[top++] = c; }\nchar pop()           { if (!isEmpty()) return stack[--top]; return '\\0'; }\n\nint main(void) {\n    Stack s1;\n    Stack s2(\"C++\");\n    s1.push('C');\n    while (!s1.isEmpty())\n        cout &lt;&lt; s1.pop();\n    cout &lt;&lt; '\\n';\n    while (!s2.isEmpty())\n        cout &lt;&lt; s2.pop();\n    cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> \ud83d\udd28 Kompiliavimas\ud83d\udca5 Klaidos <pre><code>clang++ usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp:16:1: error: constructor cannot have a return type\nusestack.cpp:17:1: error: constructor cannot have a return type\nusestack.cpp:18:6: error: 'top' was not declared in this scope\nusestack.cpp:19:16: error: 'top' was not declared in this scope\nusestack.cpp:20:28: error: 'stack' was not declared in this scope\n...\n</code></pre> <p>\ud83e\udd14 Metodai yra \u2013 kod\u0117l <code>top</code> ir <code>stack</code> nebepasiekiami?</p> Pam\u0105stykite prie\u0161 skaitant toliau... <p><code>top</code> ir <code>stack</code> yra <code>Stack</code> klas\u0117s <code>private</code> nariai. Funkcija u\u017e klas\u0117s rib\u0173 j\u0173 nemato \u2013 ji n\u0117ra klas\u0117s nar\u0117. Kaip pasakyti kompiliatoriui, kad \u0161i funkcija priklauso <code>Stack</code>?</p> <p>Atsakymas: <code>Stack::</code> \u2013 scope resolution operatorius</p> <p><code>::</code> nurodo, kuriai klasei priklauso metodas. Be jo \u2013 tai paprastos globalios funkcijos, kurios nemato <code>private</code> nari\u0173.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#2-zingsnis-metodai-isoreje-su-stack-02_ok","title":"2 \u017eingsnis: Metodai i\u0161or\u0117je su <code>Stack::</code> \u2192 <code>02_OK</code>","text":"<p>Failas: <code>16_Defining_METHODS_OUTSIDE/02_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201ePrid\u0117siu <code>Stack::</code> prie\u0161 kiekvien\u0105 metodo apibr\u0117\u017eim\u0105 \u2013 tada kompiliatorius \u017einos, kad jie priklauso klasei.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 metodai i\u0161or\u0117je su <code>Stack::</code> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#define SIZE 5\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    Stack();\n    Stack(const char* str);\n    ~Stack();\n    bool isEmpty();\n    bool isFull();\n    void push(char c);\n    char pop();\n};\n\nStack::Stack()              { top = 0; }\nStack::Stack(const char* s) { top = 0; while (*s &amp;&amp; !isFull()) stack[top++] = *s++; }\nStack::~Stack()             { }\nbool Stack::isEmpty()       { return 0 == top; }\nbool Stack::isFull()        { return SIZE == top; }\nvoid Stack::push(char c)    { if (!isFull()) stack[top++] = c; }\nchar Stack::pop()           { if (!isEmpty()) return stack[--top]; return '\\0'; }\n\nint main(void) {\n    Stack s1;\n    Stack s2(\"C++\");\n    s1.push('C');\n    while (!s1.isEmpty())\n        cout &lt;&lt; s1.pop();\n    cout &lt;&lt; '\\n';\n    while (!s2.isEmpty())\n        cout &lt;&lt; s2.pop();\n    cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang++ usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>X\nEDCBA\n</code></pre> <p>\u2705 Veikia!</p> <p><code>Stack::</code> \u2013 scope resolution operatorius <code>::</code></p> <p><pre><code>bool Stack::isEmpty() { return 0 == top; }\n//   ^^^^^             \u2190 \u201e\u0161i funkcija priklauso Stack klasei\"\n//         \u2191 top \u2013 pasiekiamas, nes funkcija yra Stack nar\u0117\n</code></pre> Klas\u0117je lieka tik deklaracijos (s\u0105saja). U\u017e klas\u0117s \u2013 apibr\u0117\u017eimai (implementacija). Tai pa\u017e\u012fstama strukt\u016bra: kaip C kalboje <code>stack.h</code> + <code>stack.c</code>.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#3-zingsnis-skaidymas-i-stackh-stackcpp-03_ok","title":"3 \u017eingsnis: Skaidymas \u012f <code>stack.h</code> + <code>stack.cpp</code> \u2192 <code>03_OK</code>","text":"<p>Failai: <code>stack.h</code> \u00b7 <code>stack.cpp</code> \u00b7 <code>user.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201e02_OK viename faile jau atrodo kaip du moduliai \u2013 tiesiog fizi\u0161kai juos atskirkime.\"</p> \ud83d\udcc4 <code>stack.h</code>\ud83d\udcc4 <code>stack.cpp</code>\ud83d\udcc4 <code>user.cpp</code>\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>#pragma once\n#define SIZE 5\n\nclass Stack {\nprivate:\n    char stack[SIZE];\n    int top;\npublic:\n    Stack();\n    Stack(const char* str);\n    ~Stack();\n    bool isEmpty();\n    bool isFull();\n    void push(char c);\n    char pop();\n};\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include \"stack.h\"\n\nStack::Stack()              { top = 0; }\nStack::Stack(const char* s) { top = 0; while (*s &amp;&amp; !isFull()) stack[top++] = *s++; }\nStack::~Stack()             { }\nbool Stack::isEmpty()       { return 0 == top; }\nbool Stack::isFull()        { return SIZE == top; }\nvoid Stack::push(char c)    { if (!isFull()) stack[top++] = c; }\nchar Stack::pop()           { if (!isEmpty()) return stack[--top]; return '\\0'; }\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include \"stack.h\"\n// std:: \u2013 naudojame piln\u0105 vard\u0105\n\nint main(void) {\n    Stack s1;\n    Stack s2(\"C++\");\n    s1.push('C');\n    while (!s1.isEmpty())\n        std::cout &lt;&lt; s1.pop();\n    std::cout &lt;&lt; '\\n';\n    while (!s2.isEmpty())\n        std::cout &lt;&lt; s2.pop();\n    std::cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>clang++ stack.cpp user.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>X\nEDCBA\n</code></pre> <p>\u2705 Pa\u017e\u012fstama strukt\u016bra \u2013 kaip C modulis, tik C++!</p> <p>C modulis vs C++ klas\u0117s modulis</p> C (03\u201309 etapai) C++ (16 etapas) S\u0105saja <code>stack.h</code> \u2013 <code>struct</code> + funkcij\u0173 deklaracijos <code>stack.h</code> \u2013 <code>class</code> su deklaracijomis Implementacija <code>stack.c</code> \u2013 funkcij\u0173 apibr\u0117\u017eimai <code>stack.cpp</code> \u2013 <code>Stack::</code> metod\u0173 apibr\u0117\u017eimai Naudotojas <code>user.c</code> + <code>#include \"stack.h\"</code> <code>user.cpp</code> + <code>#include \"stack.h\"</code> Kompiliavimas <code>gcc stack.c user.c -o app</code> <code>clang++ stack.cpp user.cpp -o app</code> <code>#pragma once</code> vietoj <code>#ifndef</code> apsaugos <p><code>#pragma once</code> \u2013 modernus, kompakti\u0161kas b\u016bdas apsaugoti nuo dvigubo \u012ftraukimo. Funkcionaliai lygiavertis klasikiniam: <pre><code>#ifndef STACK_H\n#define STACK_H\n// ...\n#endif\n</code></pre> Beveik visi modern\u016bs kompiliatoriai palaiko <code>#pragma once</code>.</p> Refleksija: kas pasikeit\u0117 nuo C modulio? <p>Strukt\u016bra labai pana\u0161i \u2013 ir tai ne atsitiktinumas. C++ <code>.h</code>/<code>.cpp</code> moduliavimas yra tiesiogin\u0117 C tradicijos t\u0105sa.  </p> <p>Skirtumas: <code>stack.h</code> dabar slepia implementacij\u0105 per <code>private:</code> \u2013 ne per opaque pointer ir atskir\u0105 <code>.c</code> fail\u0105, o per kalbos mechanizm\u0105.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_CPP_11_16/#santrauka-1116-etapai","title":"\ud83c\udfaf Santrauka: 11\u201316 etapai","text":"Nr Etapas \u017dingsniai Atradimas 11 Discovering_CPP_Struct <code>00</code> \u2192 <code>01_NC_Naive</code> Funkcija klas\u0117s viduje \u2260 globali funkcija 12 ENCAPSULATING_in_CPP_Struct <code>01_OK</code> \u2192 <code>02_OK_Attack</code> <code>this</code> + encapsulation \u2260 information hiding 13 HIDING_in_CLASS <code>01_NC_Naive</code> \u2192 <code>02_OK</code> \u2192 <code>03_NC_Attack</code> <code>class</code> = <code>private</code> pagal nutyl\u0117jim\u0105; kompiliatorius saugo 14 CONSTRUCTOR_and_DESTRUCTOR <code>00</code> \u2192 <code>01_OK</code> K\u016brimas = inicializavimas; naikinimas = automatinis 15 OVERLOADING_CONSTRUCTORS <code>00</code> \u2192 <code>01_OK</code> Overloading: tas pats vardas, skirtingi parametrai 16 DEFINING_METHODS_OUTSIDE <code>00</code> \u2192 <code>01_NC_Naive</code> \u2192 <code>02_OK</code> \u2192 <code>03_OK</code> <code>Stack::</code> + <code>.h</code>/<code>.cpp</code> moduliavimas <p>\ud83c\udf89 C++ Stack evoliucijos II dalis \u2013 baigta!</p> <p>Nuo <code>struct</code> su C stiliaus funkcijomis iki pilno C++ modulio su: - \u2705 <code>class</code> + <code>private:</code>/<code>public:</code> \u2013 information hiding - \u2705 Konstruktoriai (default + parametrinis) \u2013 automatinis lifecycle - \u2705 Destruktorius \u2013 automatinis naikinimas - \u2705 Overloading \u2013 tas pats vardas, skirtingi parametrai - \u2705 <code>Stack::</code> + <code>.h</code>/<code>.cpp</code> \u2013 pa\u017e\u012fstamas moduliavimas</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#i-dalis-nuo-naivaus-monolito-iki-profesionalaus-adt-c-kalboje","title":"I dalis: Nuo \"naivaus\" Monolito iki \"profesionalaus\" ADT C kalboje","text":""},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#kodel-stack-kodel-evoliucija","title":"\ud83c\udfaf Kod\u0117l <code>Stack</code>? Kod\u0117l evoliucija?","text":"<p>ADT vs Primityv\u016bs Tipai</p> <p>Abstraktus Duomen\u0173 Tipas (ADT) fundamentaliai skiriasi nuo \"mokyklini\u0173\" primityvi\u0173 tip\u0173 (<code>int</code>, <code>char</code>, <code>float</code>).</p> <p>Primityv\u016bs tipai - juos vis\u0173 pirma suvokiame per reik\u0161mi\u0173 aib\u0119 ir taikytinas operacijas:</p> <ul> <li> <p><code>int</code> \u2192 ..., -2, -1, 0, 1, 2, 3, ...</p> </li> <li> <p><code>char</code> \u2192 'a', 'b', 'c', ..., 'z', ...</p> </li> <li> <p><code>float</code> \u2192 3.14, -2.71, ...</p> </li> </ul> <p>ADT - juos suvokiame tik per operacijas, o ne per reik\u0161mes:</p> <ul> <li> <p><code>Stack</code> \u2192 <code>push()</code>, <code>pop()</code>, <code>isEmpty()</code>, <code>isFull()</code></p> </li> <li> <p>Mums ner\u016bpi kaip stekas atmintyje atrodo</p> </li> <li> <p>Mums svarbu tik k\u0105 galime su juo daryti, t.y. \u017einoti jo elgsen\u0105.</p> </li> </ul> <p>Kod\u0117l pasirinktas Stack?</p> <p>Stack (Stekas) - idealus ADT mokymosi pavyzdys:</p> <p>\u2705 Paprasta semantika: LIFO (Last In, First Out) - \"paskutinis \u012f\u0117jo, pirmas i\u0161\u0117jo\"</p> <p>\u2705 Minimalios operacijos: Tik 2 pagrindin\u0117s - <code>push()</code> ir <code>pop()</code></p> <p>\u2705 Ai\u0161ki teisingo/blogo elgesio riba: Lengva demonstruoti klaidas</p> <p>\u2705 Universalus: Naudojamas visur - funkcij\u0173 i\u0161kvietim\u0173 stekas, expression evaluation, undo mechanizmai</p> <p>\u2705 Evolucionuoja \u012f C++ klas\u0119: Puikus tiltas tarp C ir C++</p> <p>Evoliucijos metodologija</p> <p>\u0160ioje kelion\u0117je kiekvienas etapas sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173:</p> <ul> <li>Kompiliavimo klaidos \u2192 mokome extern/static</li> <li>Linkavimo klaidos \u2192 suprantame multiple definition</li> <li>Runtime klaidos \u2192 i\u0161mokstame pass-by-pointer</li> <li>Saugumo problemos \u2192 atrandame information hiding</li> </ul> <p>Kompiliavimo ir linkavimo klaidos bei persp\u0117jimai yra mokymosi \u012frankis, o ne kli\u016btis!</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#9-iu-etapu-evoliucija","title":"9-i\u0173 Etap\u0173 Evoliucija","text":"<p>01-03: Modulio gimimas (C modulis su header failais)</p> <p>04: Information hiding (<code>static</code>, internal linkage)</p> <p>05-06: User-Defined Type (<code>struct</code> + modulis)</p> <p>07: Opaque pointer (forward declaration)</p> <p>08-09: Pilnavertis ADT (factory pattern, lifecycle)</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1etapas-stekas-programoje","title":"1\ufe0f\u20e3Etapas: \"Stekas Programoje\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti papras\u010diausi\u0105 veikian\u010di\u0105 steko realizacij\u0105 - prad\u0117ti nuo monolitin\u0117s programos.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Para\u0161ysime vis\u0105 kod\u0105 viename faile - monolitas</li> <li>Naudosime globalius kintamuosius steko duomenims</li> <li>Suprasime monolito privalumus ir ribotumus</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive</code></p> <p>sumanymas/ketinimas</p> <p>Papras\u010diausia \u012fmanoma realizacija - viskas viename faile: duomenys, funkcijos, <code>main()</code>. Greitas prototipavimas!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas - visk\u0105 \"mato\"</li> <li>Paprastas build: Viena komanda <code>gcc usestack.c -o app</code></li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur - jokios apsaugos</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173 stek\u0173 vienu metu</li> <li>Pakartotinis naudojimas: Kaip kitas projektas panaudot\u0173 \u0161\u012f kod\u0105?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile \u2192 sunku orientuotis</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Monolitin\u0117 programa</p> <ul> <li>Papras\u010diausia prad\u017eia - viskas viename faile</li> <li>Global\u016bs duomenys - prieinami be apsaugos</li> <li>Ribojimas - tik vienas steko egzempliorius</li> <li>Sprendimas \u2192 Etapas 02: Padalinti \u012f failus</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#2etapas-stekas-faile","title":"2\ufe0f\u20e3Etapas: \"Stekas Faile\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti fizinio padalijimo \u012f failus - atskirti paslaug\u0105 (<code>stack.c</code>) nuo vartotojo (<code>user.c</code>).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Padalinsime kod\u0105 \u012f du failus - <code>stack.c</code> ir <code>user.c</code></li> <li>Susidursime su kompiliavimo klaidomis - tr\u016bksta apra\u0161\u0173</li> <li>Susidursime su linkinimo klaidomis - per daug apibr\u0117\u017eim\u0173</li> <li>Isitikinsime, kad <code>#include \"file.c\"</code> yra antipattern</li> <li>Pamatysime skirtumus tarp <code>gcc</code> ir <code>clang</code> kompiliatori\u0173 elgesio (tiesa - skirtumas kontroliuojamas)</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinsiu kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja \"proper\" C.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c/\u26a0\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> \u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror <p><pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\n</code></pre> <pre><code>user.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> \u26a0\ufe0f gcc leid\u017eia su persp\u0117jimais - netiesioginis (sistemos par\u016bpintas) funkcijos apra\u0161as (<code>implicit declaration</code>)</p> <p><pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\n</code></pre> <pre><code>user.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre> \u274c clang grie\u017etesnis - i\u0161kart klaidos! - <code>call to undeclared function</code> ir dar primena, kad C99+ nepalaiko <code>implicit declaration</code></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nesikompiliuoja-clang-perspejimai-gcc","title":"\u274c Nesikompiliuoja (clang) / \u26a0\ufe0f Persp\u0117jimai (gcc)","text":"\ud83d\udd0d Diagnoz\u0117: Tr\u016bksta funkcij\u0173 apra\u0161\u0173 (deklaracij\u0173) <p>Problema: Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, kok\u012f veiksm\u0105 jis atstovauja.</p> <p>Kod\u0117l: <pre><code>// user.c kompiliuojant:\ninit();     // \u274c Kas yra init? Kokio tipo? Ne\u017einau!\npush(c);    // \u274c Kas yra push? Kokio tipo? Ne\u017einau!\n</code></pre></p> <p>Skirtumas gcc vs clang:</p> <ul> <li>gcc (traditional): Leid\u017eia su warning - \"sp\u0117ja\" <code>int funkcija()</code> (implicit declaration)</li> <li>clang (strict): I\u0161kart error - ISO C99+ draud\u017eia implicit declarations</li> <li>Gali veikti su gcc, bet dangerous - sp\u0117jimas gali b\u016bti neteisingas!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#2-sprendimas-include-c-faila","title":"2 sprendimas: <code>#include</code> <code>.c</code> fail\u0105","text":"<p><code>02_Decomposing_to_UNITS/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> user.cstack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c <code>multiple definition of ...</code></p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nesilinkina","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Daugybiniai apibr\u0117\u017eimai (multiple definitions) <p>Problema: <code>#include \"stack.c\"</code> \u012fterpia vis\u0105 turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (funkcijos ir kintamieji) po kompiliavimo yra abiejuose <code>.o</code> failuose!</p> <p>Kod\u0117l: <pre><code>// user.c po preprocessor'iaus:\n#include \"stack.c\"  \u2192 [visas stack.c kodas \u012fterpiamas \u010dia]\n\n// Rezultatas:\n// stack.o turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n// user.o TAIP PAT turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n</code></pre></p> <p>Linkerio problema:</p> <ul> <li>Linkeris turi sulinkinti vard\u0173 kreipinius su j\u0173 apibr\u0117\u017eimais</li> <li>Bet apibr\u0117\u017eim\u0173 po du - vienas <code>stack.o</code>, kitas <code>user.o</code>!</li> <li>Kur\u012f pasirinkti? Pagal kok\u012f kriterij\u0173?</li> <li>Jei abu skirtingi - kuris teisingas?</li> </ul> <p>Linkeris deleguoja sprendim\u0105: Grie\u017etai informuoja apie \"multiple definition\" - autorius privalo pataisyti!</p> <p>Prisiminkite terminologij\u0105:</p> <ul> <li>Apra\u0161\u0173 (declarations) gali b\u016bti daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) gali b\u016bti tik VIENAS \u2705</li> </ul> <p>Sprendimas: <code>#include</code> skirtas <code>.h</code> failams (su apra\u0161ais), ne <code>.c</code> (su apibr\u0117\u017eimais)!</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#3-sprendimas-include-ta-c-faila-2","title":"3 sprendimas: <code>#include</code> t\u0105 <code>.c</code> fail\u0105 2","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojani\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> bet nebelinkinsiu su <code>stack.o</code>.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"\ud83d\udd0d Kod\u0117l BLOGAI (antipattern)? <p>Veikia, bet gr\u012f\u017eome prie monolito problemos:</p> <ul> <li>Gr\u012f\u017eome prie monolito - viskas v\u0117l viename kompiliavimo vienete</li> <li>Negalimas pakartotinis naudojimas - kaip kitas projektas panaudos?</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code> - prie\u0161 C konvencij\u0105</li> <li>Kompiliavimo laikas - <code>stack.c</code> kompiliuojamas kiekvien\u0105 kart\u0105 kai kompiliuojam <code>user.c</code></li> <li>Priklausomyb\u0117s - pakeitus <code>stack.c</code> reikia perkompiliuoti <code>user.c</code></li> </ul> <p>Teisingas kelias: Reikia header fail\u0173 (<code>.h</code>) su apra\u0161ais (prototipais)!</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>Apra\u0161ai vs Apibr\u0117\u017eimai - labai svarbu!</p> <p>K\u0105 i\u0161mokome:</p> <ul> <li>Apra\u0161ai (declarations): Funkcij\u0173 prototipai - \"sakome kad egzistuoja\"</li> <li>Apibr\u0117\u017eimai (definitions): Funkcij\u0173 realizacijos - \"sakome kaip veikia\"</li> <li>Apra\u0161\u0173 gali b\u016bti daug (\u012fvairiuose failuose) \u2705</li> <li>Apibr\u0117\u017eim\u0173 gali b\u016bti tik vienas \u2705</li> </ul> <p>Kompiliavimo vs linkavimo klaidos:</p> <ul> <li>Kompiliavimo: Tr\u016bksta apra\u0161\u0173 - implicit declaration</li> <li>Linkavimo: Daug apibr\u0117\u017eim\u0173 - multiple definition</li> </ul> <p>gcc vs clang skirtumai:</p> <ul> <li>gcc: Laisvesnis - leid\u017eia implicit declarations su warning</li> <li>clang: Grie\u017etesnis - error pagal ISO C99+</li> </ul> <p>Sprendimas \u2192 Etapas 03: Tikras C modulis su <code>.h</code> failais (apra\u0161ais)!</p> \ud83d\udcda Dar kart\u0105 terminologija: Apra\u0161as vs Apibr\u0117\u017eimas <p>C kalboje kriti\u0161kai svarbu skirti du dalykus:</p> <p>Apra\u0161as (Declaration) - \"sakome kompiliatoriui\" kad ka\u017ekas egzistuoja:</p> <ul> <li><code>int add(int a, int b);</code> \u2190 funkcijos prototipas (tai ir yra apra\u0161as!)</li> <li><code>extern int counter;</code> \u2190 kintamojo apra\u0161as</li> <li>Kompiliatorius \u017eino vard\u0105 ir tip\u0105, bet ne kaip veikia ar kur saugoma</li> <li>Gali b\u016bti daug apra\u0161\u0173 (\u012fvairiuose failuose)</li> </ul> <p>Apibr\u0117\u017eimas (Definition) - \"pasakome kompiliatoriui\" K\u0104 daryti ir KUR saugoti:</p> <ul> <li><code>int add(int a, int b) { return a + b; }</code> \u2190 funkcijos apibr\u0117\u017eimas</li> <li><code>int counter = 0;</code> \u2190 kintamojo apibr\u0117\u017eimas  </li> <li>Kompiliatorius \u017eino visk\u0105 - sugeneruoja kod\u0105 / paskiria (alokuoja) atmint\u012f</li> <li>Gali b\u016bti tik VIENAS apibr\u0117\u017eimas (vienoje vietoje)</li> </ul> <p>Aukso taisykl\u0117: </p> <ul> <li>Apra\u0161\u0173 (declarations) \u2192 daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) \u2192 tik vienas \u2705</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#3etapas-stekas-modulyje","title":"3\ufe0f\u20e3Etapas: \"Stekas Modulyje\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti tikr\u0105 C modul\u012f su header failu (<code>.h</code>) - atskirti interfeis\u0105 (k\u0105 modulis si\u016blo) nuo implementacijos (kaip veikia). I\u0161mokti apra\u0161\u0173 (declarations) ir apibr\u0117\u017eim\u0173 (definitions) skirtumo praktik\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime header fail\u0105 (<code>.h</code>) su funkcij\u0173 prototipais/apra\u0161ais ir kintam\u0173j\u0173 apra\u0161ais</li> <li>Suprasime <code>extern</code> rakta\u017eod\u017eio vaidmen\u012f</li> <li>Pamatysime kad net ir \"teisingas\" modulis gali b\u016bti nesaugus - global\u016bs kintamieji prieinami</li> <li>Pademonstruosime atak\u0105 su <code>extern</code> - tiesioginis duomen\u0173 manipuliavimas</li> </ul> <p>Dar kart\u0105!</p> <p>Apra\u0161as (declaration) \u2260 Apibr\u0117\u017eimas (definition)</p> <ul> <li>Apra\u0161as: \"Sakome kad egzistuoja\" - <code>extern int top;</code> arba <code>void push(char c);</code></li> <li>Apibr\u0117\u017eimas: \"Pasakome kaip veikia\" - <code>int top = 0;</code> arba <code>void push(char c) { ... }</code></li> <li>Taisykl\u0117: Apra\u0161\u0173 daug \u2705, apibr\u0117\u017eimas vienas \u2705</li> </ul> <p>4 sprendimai - per kompiliavimo ir linkavimo klaidas \u012f tikr\u0105 modul\u012f (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:\\Repos\\Github\\ViktorasGolubevasMIF\\cpp-2026\\code\\evolution\\stack-2026\\03_Discovering_C_MODULE\\03_NL&gt;gcc user.c stack.c -o app\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccpza694.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccpza694.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-34f531.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-34f531.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c <code>undefined reference to</code> ...</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p>Netesigai nukopijuota - taisyti <code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#4-sprendimas-atakos-bandymas","title":"4 sprendimas: \"Atakos\" bandymas","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack \n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705\n</code></pre> <pre><code>123456\n!54321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#ataka-pavyko","title":"\u2705 \"Ataka\" pavyko!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_2","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Modulis = Interfeisas/S\u0105saja + Realizacija/Implementacija = Header (antra\u0161t\u0117s failas) + Source (i\u0161eities failas)</li> <li>Modulis = <code>.h</code> + <code>.c</code></li> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problema: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#4etapas-apsaugotas-stekas-modulyje","title":"4\ufe0f\u20e3Etapas: \"Apsaugotas Stekas Modulyje\"","text":"<p><code>04_Protecting_IMPLEMENTATION</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti information hiding technik\u0105 naudojant <code>static</code> arba internal linkage - pasl\u0117pti vidin\u0119 implementacij\u0105 nuo i\u0161or\u0117s.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Suprasime kaip <code>static</code> saugo duomenis</li> <li>Pamatysime likusi\u0105 problem\u0105 - tik vienas stekas</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-ataka-su-static","title":"1 sprendimas: Ataka su static","text":"<p><code>04_Protecting_IMPLEMENTATION/01_NL_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu apsaugoti modul\u012f - prid\u0117siu <code>static</code> prie kintam\u0173j\u0173 <code>stack.c</code>.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data  // +\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    reset();\n    return 0;\n}\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;gcc stack.c user_attack.c -o user_attack\n\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.text+0x7d): undefined reference to `reset'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;clang stack.c user_attack.c -o user_attack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.text+0xc1): undefined reference to `reset'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user_attack.c -o user_attack.o  # \u2705\ngcc stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\ncollect2: error: ld returned 1 exit status\n</code></pre> \u274c undefined reference to ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user_attack.c -o user_attack.o  # \u2705\nclang stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\nclang: error: linker command failed with exit code 1\n</code></pre> \u274c <code>undefined reference to ...</code></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nesilinkina-ataka-nepavyko","title":"\u274c Nesilinkina - Ataka nepavyko!","text":"\ud83d\udd0d Diagnoz\u0117: Konfliktas tarp extern ir static <p>Problema: Header'yje deklaruojame <code>extern int top;</code>, bet <code>stack.c</code> apibr\u0117\u017eia <code>static int top = 0;</code></p> <p>Kod\u0117l nevyksta: - <code>extern</code> sako \"ie\u0161koti i\u0161or\u0117je, matomas kitose kompiliavimo vieneto\" - <code>static</code> sako \"matomas tik \u0161iame faile\" - Linkeris negali rasti <code>top</code>, nes jis internal linkage!</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#2-sprendimas-tikras-information-hiding","title":"2 sprendimas: Tikras information hiding","text":"<p><code>04_Protecting_IMPLEMENTATION/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Pa\u0161alinsiu <code>extern</code> deklaracijas i\u0161 header'o. Header'yje - tik funkcij\u0173 prototipai, o kintamieji su <code>static</code> lieka tik <code>stack.c</code> viduje.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n\nint main(void) {\n    char c;\n\n    init();\n\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia-bet_3","title":"\u2705 Veikia! Bet...","text":"<code>static</code> linkage saugo! <p><pre><code>static char stack[STACK_SIZE];  // Internal linkage\nstatic int top = 0;              // Nematomas i\u0161or\u0117je\n</code></pre> - Ataka dabar neveiks - negalima <code>extern int top;</code> - Duomenys apsaugoti nuo i\u0161orinio manipuliavimo - Information hiding pasiektas!</p> Problemos, pavojai... <ul> <li>Tik vienas stekas: <code>static</code> kintamieji global\u016bs viduje modulio</li> <li>Negalima keliems egzemplioriams: Reikia strukt\u016bros!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_3","title":"\ud83d\udca1 Pamokos","text":"<p>Static Linkage</p> <ul> <li><code>static</code> kintamieji - internal linkage (matomi tik tame faile)</li> <li>Information hiding: Vartotojas negali pasiekti <code>top</code> ar <code>stack[]</code></li> <li>Ribojimas: Tik vienas stekas - reikia user-defined type (struct)!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#5etapas-tipizuotas-stekas","title":"5\ufe0f\u20e3Etapas: \"Tipizuotas Stekas\"","text":"<p><code>05_Defining_USER_TYPE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti user-defined type (struct) - leisti keliems stek\u0173 egzemplioriams egzistuoti vienu metu.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Gr\u012f\u0161ime prie monolito, bet su struct</li> <li>I\u0161moksime <code>static</code> draudim\u0105 strukt\u016brose</li> <li>Suprasime pass-by-value vs pass-by-pointer skirtumus</li> <li>Sukursime kelis stek\u0173 egzempliorius!</li> </ul> <p>Koncepcija: 'Greitas entry point'</p> <p>Tarsi \u012fdarbinimo pokalbio \"quick solution\" - gr\u012f\u017etame prie monolito, bet su strukt\u016bra.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-static-strukturoje","title":"1 sprendimas: static strukt\u016broje","text":"<p><code>05_Defining_USER_TYPE/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu struct su <code>static</code> nariais - taip i\u0161laikysiu <code>static</code> apsaug\u0105 i\u0161 etapo 04!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 05_Defining_USER_TYPE/01_NC/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u274c\n</code></pre> <pre><code>usestack.c:7:5: error: storage class specified for 'stack'\nusestack.c:8:5: error: storage class specified for 'top'\n</code></pre> \u274c storage class specified for ...</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nekompiliuojasi","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: static draud\u017eiamas strukt\u016brose <p>Problema: C neleid\u017eia <code>static</code> storage class specifiers strukt\u016br\u0173 nariams!</p> <p>Kod\u0117l: <pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n    static int top;           // \u274c Neleid\u017eiama!\n};\n</code></pre></p> <ul> <li><code>static</code> yra storage class, ne type qualifier</li> <li>Struct nariai turi b\u016bti instance data, ne class data</li> <li>C++ leid\u017eia <code>static</code> narius klas\u0117se, bet ne C!</li> </ul> <p>Sprendimas: Pa\u0161alinti <code>static</code> - naudoti \u012fprastus narius.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#2-sprendimas-pass-by-value","title":"2 sprendimas: Pass-by-value","text":"<p><code>05_Defining_USER_TYPE/02_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pa\u0161alinsiu <code>static</code> ir perduosiu strukt\u016br\u0105 funkcijoms pagal reik\u0161m\u0119 (pass-by-value).</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/02_RT/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>(tu\u0161\u010dia)\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#kompiliuojasi-bet-blogai-veikia","title":"\u2705 Kompiliuojasi, bet BLOGAI veikia!","text":"\ud83d\udd0d Diagnoz\u0117: Pass-by-value kopijuoja strukt\u016br\u0105 <p>Problema: Runtime error - <code>pop()</code> negra\u017eina nieko!</p> <p>Kod\u0117l: <pre><code>void init(struct Stack st) {    // Kopija!\n    st.top = 0;                 // Kei\u010dia KOPIJ\u0104\n}                               // Kopija sunaikinama\n\nvoid push(struct Stack st, char c) {  // Kopija!\n    st.stack[st.top++] = c;           // Kei\u010dia KOPIJ\u0104\n}                                     // Kopija sunaikinama\n</code></pre></p> <ul> <li>Pass-by-value - funkcija gauna kopij\u0105 strukt\u016bros</li> <li>Visi pakeitimai vyksta kopijoje</li> <li>Originalas <code>main()</code> funkcijoje nepasikeis!</li> </ul> <p>Sprendimas: Naudoti pass-by-pointer - perduoti adres\u0105.</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#3-sprendimas-pass-by-pointer","title":"3 sprendimas: Pass-by-pointer","text":"<p><code>05_Defining_USER_TYPE/03_OK</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius - funkcijos gaus strukt\u016bros adres\u0105, gal\u0117s keisti original\u0105!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/03_OK/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia","title":"\u2705 Veikia!","text":"Pass-by-pointer sprend\u017eia problem\u0105! <p><pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia ORIGINAL\u0104\n}\n\nstruct Stack st1, st2;  // Du stekai!\ninit(&amp;st1);\ninit(&amp;st2);\n</code></pre> - Pass-by-pointer - funkcija gauna adres\u0105 - Visi pakeitimai vyksta originale - Galime tur\u0117ti kelis egzempliorius!</p> Problemos, pavojai... <ul> <li>Strukt\u016bra vie\u0161a: Vartotojas mato <code>struct Stack { char stack[100]; int top; };</code></li> <li>Nariai prieinami: Gali ra\u0161yti <code>st1.top = 999;</code> - sugadinti b\u016bsen\u0105</li> <li>N\u0117ra information hiding: Reikia encapsulation + modulio!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_4","title":"\ud83d\udca1 Pamokos","text":"<p>User-Defined Type</p> <ul> <li>Struct leid\u017eia kurti naujus tipus</li> <li><code>static</code> draud\u017eiamas strukt\u016br\u0173 nariuose C kalboje</li> <li>Pass-by-value kopijuoja \u2192 pakeitimai nei\u0161lieka</li> <li>Pass-by-pointer \u2192 galima keisti original\u0105</li> <li>Keli egzemplioriai: <code>struct Stack st1, st2;</code> \u2705</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#6etapas-tipizuotas-stekas-modulyje","title":"6\ufe0f\u20e3Etapas: \"Tipizuotas Stekas Modulyje\"","text":"<p><code>06_ENCAPSULATING_UDT_in_Module</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Encapsulation - apjungti duomenis ir funkcijas modulyje. Sukurti struct + modulis kombinacij\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Apjungsime id\u0117jas: 05 etapas (struct) + 03 etapas (modulis)</li> <li>Sukursime modulin\u012f user-defined type</li> <li>Pamatysime kad encapsulation \u2260 information hiding</li> </ul> <p>Koncepcija: Apjungimas id\u0117j\u0173</p> <p>Struct i\u0161 05 + Modulis i\u0161 03 = Strukt\u016brizuotas modulis</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-modulinis-udt","title":"1 sprendimas: Modulinis UDT","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu struct apibr\u0117\u017eim\u0105 \u012f modul\u012f - tur\u0117siu stack.h su strukt\u016bros deklaracija ir funkcij\u0173 prototipais, stack.c su realizacija.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia-bet_4","title":"\u2705 Veikia! Bet...","text":"Modulinis UDT veikia! <ul> <li>\u2705 Struct modulyje</li> <li>\u2705 Keli egzemplioriai</li> <li>\u2705 Funkcijos dirba su pointer'iais</li> <li>\u2705 Pakartotinis naudojimas</li> </ul> Problemos, pavojai... <ul> <li>Strukt\u016bros nariai VIE\u0160I: Header'yje matoma visa strukt\u016bros anatomija</li> <li>Galima tiesiogin\u0117 manipuliacija: <code>st.top = 999;</code></li> <li>Encapsulation \u2260 Information hiding!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#2-sprendimas-ataka-pavyksta","title":"2 sprendimas: Ataka pavyksta","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/02_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruosiu, kad net ir modulinis UDT n\u0117ra saugus - \"attacker\" gali tiesiogiai keisti strukt\u016bros narius.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> <pre><code>HACKED!\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Strukt\u016bros nariai prieinami <pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima manipuliuoti!\nst.stack[0] = 'X';  // \u2190 Galima keisti!\n</code></pre> <p>Encapsulation \u2260 Information hiding: - Encapsulation - duomenys + funkcijos kartu modulyje \u2705 - Information hiding - duomen\u0173 strukt\u016bra pasl\u0117pta \u274c</p> <p>Sprendimas \u2192 Etapas 07: Opaque pointer (forward declaration)</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_5","title":"\ud83d\udca1 Pamokos","text":"<p>Encapsulation vs Information Hiding</p> <ul> <li>Encapsulation: Duomenys + funkcijos kartu (struct + modulis)</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos nuo vartotojo</li> <li>Problema: Header'yje matoma <code>struct Stack { ... };</code> - nariai prieinami!</li> <li>Reikia: Opaque pointer - tik deklaracija, ne apibr\u0117\u017eimas!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#7etapas-pasleptas-stekas","title":"7\ufe0f\u20e3Etapas: \"Pasl\u0117ptas Stekas\"","text":"<p><code>07_HIDING_UDT_Information</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Information hiding - pasl\u0117pti strukt\u016bros detales nuo vartotojo. Naudoti opaque pointer (forward declaration).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Panaudosime incomplete type - <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Suprasime forward declaration koncepcij\u0105</li> <li>I\u0161siai\u0161kinsime kod\u0117l reikalingi pointer'iai</li> <li>Pamatysime uninicializuot\u0173 pointer'i\u0173 problem\u0105</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-incomplete-type","title":"1 sprendimas: Incomplete type","text":"<p><code>07_HIDING_UDT_Information/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu strukt\u016bros apibr\u0117\u017eim\u0105 \u012f <code>stack.c</code>, o header'yje palikusiu tik deklaracij\u0105 - <code>struct Stack;</code> (forward declaration).</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;gcc stack.c user_attack.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654\n2nd Stack is empty\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:7:19: error: storage size of 'st1' isn't known\nuser.c:7:25: error: storage size of 'st2' isn't known\n</code></pre> \u274c storage size isn't known</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nekompiliuojasi_1","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: Incomplete type - ne\u017einomas dydis <p>Problema: <code>user.c</code> bando sukurti <code>struct Stack st1, st2;</code> bet kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;  // Forward declaration - \"incomplete type\"\n\n// Bando sukurti:\nstruct Stack st1;  // \u274c sizeof(Stack) ne\u017einomas!\n</code></pre></p> <ul> <li>Incomplete type - kompiliatorius \u017eino kad tipas egzistuoja, bet ne\u017eino jo strukt\u016bros</li> <li>Negalima alokuoti stack'e - <code>sizeof()</code> ne\u017einomas</li> <li>Galima tik pointer'iai - <code>sizeof(pointer)</code> visada \u017einomas!</li> </ul> <p>Sprendimas: Naudoti pointer'ius - <code>struct Stack *pst1, *pst2;</code></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#2-sprendimas-bandymas-su-malloc","title":"2 sprendimas: Bandymas su malloc","text":"<p><code>07_HIDING_UDT_Information/02_NC</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius ir <code>malloc()</code> - alokuosiu dinami\u0161kai, nes <code>sizeof()</code> ne\u017einomas kompiliavimo metu.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    //// ATTACK!\n    pst2-&gt;stack[pst2-&gt;top++] = '!';\n    ////\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\ngcc -c user_attack.c\n\nuser_attack.c: In function 'main':\nuser_attack.c:20:9: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |         ^~\nuser_attack.c:20:21: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                     ^~\n*/\n\n/*\nclang -c user_attack.c\nuser_attack.c:20:9: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |     ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:20:21: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                 ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:8:24: error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre> \u274c sizeof to incomplete type</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#nekompiliuojasi_2","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: sizeof() incomplete type <p>Problema: <code>user.c</code> bando <code>malloc(sizeof(struct Stack))</code> bet <code>sizeof()</code> reikia pilno tipo!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;\n\n// Bando:\nmalloc(sizeof(struct Stack));  // \u274c sizeof ne\u017einomas!\n</code></pre></p> <ul> <li><code>malloc()</code> reikia dyd\u017eio - kiek bait\u0173 alokuoti</li> <li><code>sizeof()</code> reikia pilno tipo - incomplete type nepakanka</li> <li>Vartotojas negali alokuoti pats!</li> </ul> <p>Sprendimas: Reikia factory funkcijos modulyje - <code>create()</code> kuris \u017eino <code>sizeof()</code></p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#3-sprendimas-neininicializuotos-rodykles","title":"3 sprendimas: Neininicializuotos rodykl\u0117s","text":"<p><code>07_HIDING_UDT_Information/03_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu su pointer'iais be alokavimo - gal veiks?</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\udca5 \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/user.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app  # \ud83d\udca5\n</code></pre> <pre><code>Segmentation fault (core dumped)\n</code></pre> \ud83d\udca5 Runtime crash!</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#kompiliuojasi-ir-linkuojasi-bet-crash","title":"\u2705 Kompiliuojasi ir linkuojasi, bet CRASH!","text":"\ud83d\udd0d Diagnoz\u0117: Uninitialized pointers <p>Problema: Runtime crash - segmentation fault!</p> <p>Kod\u0117l: <pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos rodykl\u0117s!\ninit(pst1);  // \ud83d\udca5 pst1 rodo \u012f niekur (garbage value)\n</code></pre></p> <ul> <li>Pointer'iai neininicializuoti - turi atsitiktines reik\u0161mes</li> <li>Dereferencing random adreso \u2192 segmentation fault</li> <li>N\u0117ra atminties - pointer'ius turi rodyti \u012f galiojan\u010di\u0105 atmint\u012f!</li> </ul> <p>Sprendimas \u2192 Etapas 08: Factory pattern - <code>create()</code> funkcija, kuri: - Alokuoja atmint\u012f su <code>malloc()</code> - Inicializuoja strukt\u016br\u0105 - Gr\u0105\u017eina valid\u0173 pointer'\u012f</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_6","title":"\ud83d\udca1 Pamokos","text":"<p>Opaque Pointer Pattern</p> <ul> <li>Forward declaration: <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Incomplete type: Kompiliatorius \u017eino vard\u0105, bet ne strukt\u016br\u0105</li> <li>Negalima: <code>struct Stack st;</code> - ne\u017einomas <code>sizeof()</code></li> <li>Galima: <code>struct Stack *pst;</code> - pointer'io dydis \u017einomas</li> <li>Problema: Vartotojas negali alokuoti - reikia factory!</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos \u2705</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#8etapas-stekas-su-dinaminiu-valdymu","title":"8\ufe0f\u20e3Etapas: \"Stekas su Dinaminiu Valdymu\"","text":"<p><code>08_Acquiring_RESOURCES</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Factory pattern - sukurti <code>create()</code> ir <code>destroy()</code> funkcijas, kurios valdo objekt\u0173 lifecycle - k\u016brim\u0105 ir naikinim\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime <code>create()</code> - alokuoja ir inicializuoja</li> <li>Sukursime <code>destroy()</code> - atlaisvina atmint\u012f</li> <li>Suprasime resource acquisition ir cleanup svarb\u0105</li> <li>Pamatysime manual lifecycle management C kalboje</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-factory-pattern","title":"1 sprendimas: Factory pattern","text":"<p><code>08_Acquiring_RESOURCES/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu factory funkcijas modulyje: <code>create()</code> alokuos ir inicializuos, <code>destroy()</code> atlaisvins atmint\u012f. Vartotojas tur\u0117s validius pointer'ius!</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#veikia_1","title":"\u2705 Veikia!","text":"Factory pattern veikia! <pre><code>// K\u016brimas (acquisition)\nstruct Stack *pst1 = create();\n\n// Naudojimas\npush(pst1, '1');\nchar c = pop(pst1);\n\n// Naikinimas (cleanup)\ndestroy(pst1);\n</code></pre> <p>Privalumai: - \u2705 Dinamin\u0117 alokacija - <code>malloc()</code> modulyje - \u2705 Inicializacija - <code>create()</code> u\u017etikrina teising\u0105 b\u016bsen\u0105 - \u2705 Cleanup - <code>destroy()</code> atlaisvina atmint\u012f - \u2705 Keli egzemplioriai - kiek tik reikia! - \u2705 Information hiding - strukt\u016bra pasl\u0117pta</p> Problemos, pavojai... <ul> <li>Manual lifecycle: Vartotojas turi prisiminti <code>destroy()</code></li> <li>Memory leak: U\u017emir\u0161us <code>destroy()</code> - memory leak</li> <li>Dangling pointer: Po <code>destroy()</code> pointer'is invalid</li> <li>Double free: Du kartus <code>destroy()</code> - undefined behavior</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_7","title":"\ud83d\udca1 Pamokos","text":"<p>Factory Pattern &amp; Resource Management</p> <ul> <li><code>create()</code> - alokuoja + inicializuoja \u2192 acquisition</li> <li><code>destroy()</code> - atlaisvina \u2192 cleanup</li> <li>Manual lifecycle: Vartotojas atsakingas u\u017e <code>destroy()</code></li> <li>C++ evoliucija: Konstruktorius + destruktorius automati\u0161kai!</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#9etapas-stekas-su-gyvavimo-ciklu","title":"9\ufe0f\u20e3Etapas: \"Stekas su Gyvavimo Ciklu\"","text":"<p><code>09_Completing_LIFECYCLE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>U\u017ebaigti piln\u0105 ADT C kalboje - prid\u0117ti visas lifecycle funkcijas, error handling, ir pasiekti maksimal\u0173 abstrakcijos lyg\u012f.</p> <p>\ud83d\udd0d K\u0105 pasiek\u0117me</p> <ul> <li>\u2705 Information hiding - opaque pointer</li> <li>\u2705 Encapsulation - duomenys + funkcijos modulyje</li> <li>\u2705 Multiple instances - kiek tik reikia stek\u0173</li> <li>\u2705 Factory pattern - <code>create()</code> / <code>destroy()</code></li> <li>\u2705 Pilnas lifecycle - acquisition \u2192 usage \u2192 cleanup</li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#1-sprendimas-pilnas-c-adt","title":"1 sprendimas: Pilnas C ADT","text":"<p><code>09_Completing_LIFECYCLE/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Apibendrinsiu visk\u0105 - prid\u0117siu visas reikalingas funkcijas pilnam ADT funkcionavimui.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pilnas-c-adt","title":"\u2705 Pilnas C ADT!","text":"Visi ADT reikalavimai \u012fvykdyti! <p>ADT principai C kalboje:</p> <ol> <li>\u2705 Information hiding - strukt\u016bra pasl\u0117pta (opaque pointer)</li> <li>\u2705 Encapsulation - duomenys + operacijos modulyje</li> <li>\u2705 Multiple instances - <code>struct Stack *pst1, *pst2, ...;</code></li> <li>\u2705 Lifecycle management - <code>create()</code> \u2192 use \u2192 <code>destroy()</code></li> <li>\u2705 Factory pattern - kontroliuota k\u016brimas/naikinimas</li> </ol> <p>Pilnas ADT API: <pre><code>struct Stack *create();        // Acquisition\nvoid init(struct Stack *pst);  // Initialization\nvoid push(struct Stack *pst, char c);\nchar pop(struct Stack *pst);\nint isEmpty(struct Stack *pst);\nint isFull(struct Stack *pst);\nvoid destroy(struct Stack *pst);  // Cleanup\n</code></pre></p> C kalbos ribotumai <ul> <li>Manual lifecycle: Reikia prisiminti <code>destroy()</code></li> <li>No automatic cleanup: U\u017emir\u0161us - memory leak</li> <li>Syntax: <code>push(pst, 'a')</code> vietoj <code>pst-&gt;push('a')</code></li> <li>No operator overloading: Negalima <code>pst1 = pst2;</code></li> </ul>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#pamokos_8","title":"\ud83d\udca1 Pamokos","text":"<p>C ADT \u2192 C++ Class Evolution</p> <p>C kalboje pasiek\u0117me: - \u2705 Information hiding - \u2705 Encapsulation - \u2705 Factory pattern - \u2705 Manual lifecycle management</p> <p>C++ prideda: - \ud83d\ude80 Konstruktorius - automatic <code>create()</code> - \ud83d\ude80 Destruktorius - automatic <code>destroy()</code> - \ud83d\ude80 Method syntax - <code>s.push('a')</code> - \ud83d\ude80 Operator overloading - <code>s1 = s2;</code> - \ud83d\ude80 RAII - Resource Acquisition Is Initialization</p>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#evoliucijos-santrauka","title":"\ud83c\udfaf Evoliucijos santrauka","text":""},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai Sprendim\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis + extern 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> linkage 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#suolis-i-c","title":"\ud83d\ude80 \u0160uolis \u012f C++","text":""},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\nchar c = pop(s);\ndestroy(s);  // \u2190 Reikia prisiminti!\n</code></pre>"},{"location":"Paskaitos/02/02_Paskaita_Stack_Evolution_C_01_09/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius (automatic create)\ns.push('a');          // Method syntax\nchar c = s.pop();\n// Destruktorius automati\u0161kai (automatic destroy)\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/","title":"Stack ADT Evoliucija C++ kalboje","text":""},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#ii-dalis-nuo-c-struct-iki-c-class-klases-anatomija","title":"II dalis: Nuo C <code>struct</code> iki C++ <code>class</code> \u2013 Klas\u0117s Anatomija","text":"<p>T\u0119sinys po: I dalies 9 etap\u0173 \"Pilnaver\u010dio vartotojo apibr\u0117\u017eto tipo\" (C UDT su opaque pointer ir factory pattern) Tikslas: Atrasti/suvokti C++ klas\u0119 <code>class</code> kaip naujos kartos <code>struct</code> Metodologija: Tas pats principas \u2013 klaidos = mokymo(si)s \u012frankis!</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#prisiminkime-kur-sustojome","title":"\ud83d\udd01 Prisiminkime: Kur sustojome?","text":"<p>I dalis: Pasiek\u0117me piln\u0105 C ADT (09 etapas)</p> <ul> <li>\u2705 Information hiding (<code>static</code> nariai, opaque pointer)</li> <li>\u2705 Encapsulation (duomenys + funkcijos modulyje)</li> <li>\u2705 Multiple instances (su rodykl\u0117mis <code>*pst1</code>, <code>*pst2</code>, ...)</li> <li>\u2705 Lifecycle management (<code>create()</code> \u2192 <code>destroy()</code>)</li> </ul> <p>Bet C kalboje liko nei\u0161spr\u0119st\u0173 problem\u0173...</p> <ul> <li>Manual lifecycle: programuotojas privalo prisiminti <code>destroy()</code> \u2013 u\u017emir\u0161tus memory leak</li> <li>No operator overloading: negalima nat\u016bralaus priskyrimo/kopijavimo <code>pst1 = pst2;</code></li> <li>Opaque pointer/Forward declaration biurokratija: <code>create()</code>/<code>destroy()</code> \u2013 rankinis darbas, kur\u012f gal\u0117t\u0173 automatizuoti kompiliatorius</li> </ul>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#suolis-c-adt-c-class","title":"\ud83d\ude80 \u0160uolis: C ADT \u2192 C++ Class","text":"<pre><code>// C (09 etapas) \u2013 rankinis valdymas\nstruct Stack *s = create(); // rankinis create()\npush(s, 'a');               // C funkcijos i\u0161kvietimo sintaks\u0117: funkcija(objektas, ...)\nchar c = pop(s);            // C objektas paprastai perduodamas rodykle=adresu\ndestroy(s);                 // \u2190 REIKIA PRISIMINTI!\n</code></pre> <pre><code>// C++ \u2013 automatinis valdymas\nStack s;               // konstruktorius = automatinis create()\ns.push('a');           // metodo sintaks\u0117: objektas.funkcija(...)\nchar c = s.pop();\n..}                    // destruktorius = automatinis destroy()\n</code></pre> <p>Paradigminis pokytis</p> <p>C: (i\u0161orin\u0117s/nesavos/globalios) funkcijos valdo objekt\u0105 \u2192 <code>push(s, 'a')</code> C++: objektas turi (savas) funkcijas \u2192 <code>s.push('a')</code> </p> <p>Tai ne tik sintaks\u0117s skirtumas \u2013 tai kitoks m\u0105stymo b\u016bdas apie kod\u0105.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#ii-dalies-kelione","title":"\ud83d\uddfa\ufe0f II dalies kelion\u0117","text":"Nr Etapas \u017dingsniai Esm\u0117 11 Discovering_CPP_Struct <code>00</code> \u2192 <code>01_NC_Naive</code> NC: <code>main()</code> nebemato funkcij\u0173 globaliai 12 ENCAPSULATING_in_CPP_Struct <code>01_OK</code> \u2192 <code>02_OK_Attack</code> <code>this</code> gimimas; <code>struct</code> dar atviras 13 HIDING_in_CLASS <code>01_NC_Naive</code> \u2192 <code>02_OK</code> \u2192 <code>03_NC_Attack</code> Paradigminis switch: kompiliatorius saugo!"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#11-etapas-11_discovering_cpp_struct","title":"1\ufe0f\u20e31\ufe0f\u20e3 Etapas: <code>11_Discovering_CPP_Struct</code>","text":"<p><code>11_Discovering_CPP_Struct</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Suprasti, kas nutinka kai C funkcij\u0173 apibr\u0117\u017eimus perkeliame \u012f <code>struct {}</code> blok\u0105 \u2013 ir <code>main()</code> jas vis dar kvie\u010dia C stiliumi.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#0-zingsnis-referentinis-taskas-00","title":"0 \u017eingsnis: Referentinis ta\u0161kas \u2192 <code>00</code>","text":"<p>Failas: <code>11_Discovering_CPP_Struct/00/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>Pradedame nuo to paties kodo kaip <code>05/03_OK/usestack.c</code> \u2013 tik pl\u0117tinys <code>.cpp</code>. Funkcijos yra i\u0161or\u0117je <code>struct {}</code>. Tai veikia \u2013 ir C, ir C++ atveju.</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 C stilius, funkcijos i\u0161or\u0117je <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nstatic void reset(struct Stack *pst) { pst-&gt;top = 0; }\nvoid init(struct Stack *pst)         { pst-&gt;top = 0; }\nint isEmpty(struct Stack *pst)       { return 0 == pst-&gt;top; }\nint isFull(struct Stack *pst)        { return SIZE == pst-&gt;top; }\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) pst-&gt;stack[pst-&gt;top++] = c;\n}\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) return pst-&gt;stack[--pst-&gt;top];\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n    struct Stack st1, st2;\n    init(&amp;st1);\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80 <pre><code>clang usestack.cpp -o app   # \u2705\n./app\n</code></pre> <p>\u2705 Veikia \u2013 kaip ir C atveju. Tai m\u016bs\u0173 atspirties ta\u0161kas.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#1-zingsnis-funkcijos-i-struct-vidu-main-nepakeistas-01_nc_naive","title":"1 \u017eingsnis: Funkcijos \u012f <code>struct</code> vid\u0173, <code>main()</code> nepakeistas \u2192 <code>01_NC_Naive</code>","text":"<p>Failas: <code>11_Discovering_CPP_Struct/01_NC_Naive/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201ePerkeliu funkcij\u0173 apibr\u0117\u017eimus \u012f <code>struct Stack {}</code> vid\u0173. <code>main()</code> lieka nepakeistas \u2013 tur\u0117t\u0173 vis tiek veikti, ne?\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 funkcijos viduje, <code>main()</code> C stiliumi <pre><code>#include &lt;stdio.h&gt;\n// ===&gt; stack dalis\n#define SIZE 5\nstruct Stack {\n    char stack[SIZE];\n    int top;\n    static void reset(struct Stack *pst) { pst-&gt;top = 0; }  // \u2190 viduje!\n    void init(struct Stack *pst)         { pst-&gt;top = 0; }\n    int isEmpty(struct Stack *pst)       { return 0 == pst-&gt;top; }\n    int isFull(struct Stack *pst)        { return SIZE == pst-&gt;top; }\n    void push(struct Stack *pst, char c) {\n        if (!isFull(pst)) pst-&gt;stack[pst-&gt;top++] = c;\n    }\n    char pop(struct Stack *pst) {\n        if (!isEmpty(pst)) return pst-&gt;stack[--pst-&gt;top];\n        return '\\0';\n    }\n};\n// ===&gt; user dalis\nint main(void) {\n    char c;\n    struct Stack st1, st2;\n    init(&amp;st1);                // \u2190 C stilius \u2013 globaliai ie\u0161ko 'init'\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 Kompiliavimas\ud83d\udca5 Klaidos <pre><code>clang usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp:22:5: error: use of undeclared identifier 'init'; did you mean 'int'?\nusestack.cpp:23:15: error: use of undeclared identifier 'isFull'\nusestack.cpp:23:60: error: use of undeclared identifier 'push'\nusestack.cpp:24:13: error: use of undeclared identifier 'isEmpty'\nusestack.cpp:24:36: error: use of undeclared identifier 'pop'\n... (10 klaid\u0173 i\u0161 viso)\n</code></pre> <p>\ud83e\udd14 Funkcijos yra faile \u2013 kod\u0117l kompiliatorius j\u0173 nemato?!</p> Pam\u0105stykite prie\u0161 skaitant toliau... <p><code>init</code>, <code>push</code>, <code>pop</code> ir kt. yra apibr\u0117\u017etos \u2013 tik viduje <code>struct Stack {}</code>. <code>main()</code> jas kvie\u010dia kaip globalias: <code>init(&amp;st1)</code>. Kas pasikeit\u0117, kai funkcijos \u201epersik\u0117l\u0117\" \u012f vid\u0173?</p> <p>Atsakymas: funkcija \u201epersik\u0117l\u0117\" \u2013 ir i\u0161nyko i\u0161 globalios erdv\u0117s</p> <p>Kai funkcija yra viduje <code>struct Stack {}</code>, ji neb\u0117ra globali funkcija. Ji tapo klas\u0117s nariu \u2013 ir dabar priklauso <code>Stack</code> vard\u0173 erdvei.</p> <p><code>main()</code> ie\u0161ko <code>init</code> globaliai \u2013 ir neranda. Kompiliatorius pasi\u016blo: \u201edid you mean 'int'?\" \u2013 nes globaliai \u017eino tik <code>int</code>, ne <code>init</code>.</p> <p>Taisymas akivaizdus: kviesti per objekt\u0105 \u2013 <code>st1.init(...)</code>.</p> Beje: <code>static reset</code> nekelia klaidos... <p><code>static void reset(...)</code> viduje <code>struct</code> kompiliatorius priima be skundo. <code>static</code> klas\u0117s viduje rei\u0161kia visai k\u0105 kit\u0105 nei C kalboje \u2013 tai klas\u0117s lygio narys, ne egzemplioriaus. Prie \u0161io <code>static</code> gr\u012f\u0161ime v\u0117liau.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#2-zingsnis-main-pakeiciamas-i-objekto-sintakse-02_ok","title":"2 \u017eingsnis: <code>main()</code> pakei\u010diamas \u012f objekto sintaks\u0119 \u2192 <code>02_OK</code>","text":"<p>Failas: <code>11_Discovering_CPP_Struct/02_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eJei funkcijos priklauso <code>Stack</code> \u2013 kviesiu jas per objekt\u0105: <code>st1.init(...)</code>.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 tik <code>main()</code> pakeistas <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 5\nstruct Stack {\n    char stack[SIZE];\n    int top;\n    static void reset(struct Stack *pst) { pst-&gt;top = 0; }\n    void init(struct Stack *pst)         { pst-&gt;top = 0; }\n    int isEmpty(struct Stack *pst)       { return 0 == pst-&gt;top; }\n    int isFull(struct Stack *pst)        { return SIZE == pst-&gt;top; }\n    void push(struct Stack *pst, char c) {\n        if (!isFull(pst)) pst-&gt;stack[pst-&gt;top++] = c;\n    }\n    char pop(struct Stack *pst) {\n        if (!isEmpty(pst)) return pst-&gt;stack[--pst-&gt;top];\n        return '\\0';\n    }\n};\nint main(void) {\n    char c;\n    struct Stack st1, st2;\n    st1.init(&amp;st1);                                          // \u2190 objekto sintaks\u0117\n    while ((!st1.isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(&amp;st1, c);\n    while (!st1.isEmpty(&amp;st1)) putchar(st1.pop(&amp;st1));\n    putchar('\\n');\n    st2.init(&amp;st2);\n    while ((!st2.isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(&amp;st2, c);\n    while (!st2.isEmpty(&amp;st2)) putchar(st2.pop(&amp;st2));\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\ndlrow\n</code></pre> <p>\u2705 Veikia!</p> <p>Bet... <code>st1.init(&amp;st1)</code> \u2013 ar tai normalu?</p> <p>Veikia \u2013 bet atrodo keistai. Kvie\u010diame per objekt\u0105 <code>st1</code>, ir dar atskirai perduodame <code>&amp;st1</code> kaip parametr\u0105. Objektas perduodamas du kartus: vien\u0105 kart\u0105 kaip kviet\u0117jas, antr\u0105 kart\u0105 kaip argumentas.</p> <p>Tai yra kitas \u017eingsnis: kaip i\u0161mesti <code>struct Stack *pst</code> parametr\u0105 \u2013 ir leisti C++ tai tvarkyti automati\u0161kai.</p> <p></p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#12-etapas-12_encapsulating_in_cpp_struct","title":"1\ufe0f\u20e32\ufe0f\u20e3 Etapas: <code>12_ENCAPSULATING_in_CPP_Struct</code>","text":"<p><code>12_ENCAPSULATING_in_CPP_Struct</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mesti <code>struct Stack *pst</code> parametr\u0105 \u2013 suprasti <code>this</code>. Ir pamatyti, kad <code>struct</code> su metodais dar nesuteikia information hiding.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#1-zingsnis-ismetame-pst-parametra-01_ok","title":"1 \u017eingsnis: I\u0161metame <code>pst</code> parametr\u0105 \u2192 <code>01_OK</code>","text":"<p>Failas: <code>12_ENCAPSULATING_in_CPP_Struct/01_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\"<code>st1.init(&amp;st1)</code> \u2013 absurdas. Objektas jau \u017eino, kas jis yra \u2013 i\u0161meskime <code>&amp;st1</code> kaip parametr\u0105!\"</p> \ud83d\udcc4 <code>usestack.cpp</code> <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 5\nstruct Stack {\n    char stack[SIZE];\n    int top;\n\n    void reset()       { this-&gt;top = 0; }     // `this` \u2013 rodykl\u0117 \u012f \"save\"\n    void init()        { top = 0; }            // \u2190 pst i\u0161mestas, top tiesiogiai\n    int isEmpty()      { return 0 == top; }\n    int isFull()       { return SIZE == top; }\n    void push(char c) {\n        if (!isFull()) stack[top++] = c;\n    }\n    char pop() {\n        if (!isEmpty()) return stack[--top];\n        return '\\0';\n    }\n};\nint main(void) {\n    char c;\n    struct Stack st1;\n    Stack st2;              // \u2190 C++ leid\u017eia be \"struct\"!\n    st1.init();\n    while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n    while (!st1.isEmpty()) putchar(st1.pop());\n    putchar('\\n');\n    st2.init();\n    while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n    while (!st2.isEmpty()) putchar(st2.pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\ndlrow\n</code></pre> <p>\u2705 Veikia!</p> <p>Kas nutiko su <code>pst</code>?</p> <p>Prie\u0161 (11 \u2013 dar su <code>pst</code>): <pre><code>void init(struct Stack *pst) { pst-&gt;top = 0; }\nst1.init(&amp;st1);   // \u2190 objektas du kartus \u2013 absurdas\n</code></pre> Po (12 \u2013 be <code>pst</code>): <pre><code>void init() { top = 0; }\nst1.init();        // \u2190 \u0161varu\n</code></pre> Kompiliatorius automati\u0161kai perduoda rodykl\u0119 \u012f kvie\u010diant\u012f objekt\u0105. Ta pasl\u0117pta rodykl\u0117 vadinamas <code>this</code>.</p> Kas yra <code>this</code>? <p><pre><code>// Tai k\u0105 mes ra\u0161ome:\nvoid init() { top = 0; }\n\n// Tai k\u0105 kompiliatorius \u201emato\" po gaubtu:\nvoid init(Stack* const this) { this-&gt;top = 0; }\n</code></pre> Kai ra\u0161ome <code>st1.init()</code> \u2013 kompiliatorius i\u0161ver\u010dia \u012f <code>Stack::init(&amp;st1)</code>. <code>this</code> visada rodo \u012f t\u0105 objekt\u0105, kuris kviet\u0117 metod\u0105.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#2-zingsnis-ataka-vis-dar-pavyksta-02_ok_attack","title":"2 \u017eingsnis: Ataka vis dar pavyksta \u2192 <code>02_OK_Attack</code>","text":"<p>Failas: <code>12_ENCAPSULATING_in_CPP_Struct/02_OK_Attack/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eTurime <code>struct</code> su metodais \u2013 ar duomenys dabar saug\u016bs?\"</p> \ud83d\udcc4 Atakos kodas <code>main()</code> dalyje <pre><code>// ... (tas pats struct Stack su metodais)\nint main(void) {\n    // ... \u012fprastas naudojimas su st1 ...\n    st2.init();\n    while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n//// ATTACK!\nst2.stack[st2.top++] = '!';\n////\n    while (!st2.isEmpty()) putchar(st2.pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang usestack.cpp -o app   # \u2705 kompiliuoja!\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\n!dlrow   \u2190 '!' \u012fterptas \u2013 ataka pavyko!\n</code></pre> <p>\u2705 Kompiliuoja. \u2705 Veikia. \u274c Ataka pavyko!</p> <p><code>struct Stack</code> nariai yra vie\u0161i \u2013 bet kuris kodas gali juos tiesiogiai keisti. Metodai viduje \u2013 tai encapsulation. Bet duomenys atviri \u2013 ne information hiding.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#terminu-painiava-encapsulation-vs-information-hiding","title":"\ud83d\udccc Termin\u0173 \"painiava\": Encapsulation vs Information Hiding","text":"<p>Dvi skirtingos s\u0105vokos \u2013 da\u017enai supainiojamos</p> <p>Encapsulation \u2013 duomen\u0173 ir operacij\u0173 suvienijimas \u012f vien\u0105 vienet\u0105: <pre><code>struct Stack {\n    char stack[SIZE];  // duomenys\n    int top;\n    void push(char c); // operacijos kartu!\n    char pop();\n};\n</code></pre> \u2705 Pasiekta jau 12 etape \u2013 <code>struct</code> su metodais.</p> <p>Information Hiding \u2013 vidin\u0117s strukt\u016bros pasl\u0117pimas nuo vartotojo: <pre><code>class Stack {\nprivate:\n    char stack[SIZE];  // \u2190 nematoma i\u0161 i\u0161or\u0117s\n    int top;\npublic:\n    void push(char c);\n    char pop();\n};\n</code></pre> \u2705 Pasiekta 13 etape \u2013 <code>class</code> su <code>private:</code>.</p> <p>Encapsulation \u2260 Information Hiding</p> Encapsulation Information Hiding C analogas 06 etapas (<code>struct</code> modulyje) 07\u201309 etapai (opaque pointer) C++ analogas 12 etapas (<code>struct</code> su metodais) 13 etapas (<code>class</code> + <code>private:</code>) Kas kartu? Duomenys + funkcijos Taip pat + duomenys pasl\u0117pti Ataka \u2705 Pavyksta \u274c NC \u2013 kompiliatorius blokuoja <p>Encapsulation yra b\u016btina s\u0105lyga, bet nepakankama information hiding pasiekti.</p> <p></p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#13-etapas-13_hiding_in_class","title":"1\ufe0f\u20e33\ufe0f\u20e3 Etapas: <code>13_HIDING_in_CLASS</code>","text":"<p><code>13_HIDING_in_CLASS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Suprasti, kuo <code>class</code> skiriasi nuo <code>struct</code> \u2013 ir kod\u0117l tai yra paradigminis pokytis.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#1-zingsnis-plikas-class-be-specifikatoriu-01_nc_naive","title":"1 \u017eingsnis: Plikas <code>class</code> be specifikatori\u0173 \u2192 <code>01_NC_Naive</code>","text":"<p>Failas: <code>13_HIDING_in_CLASS/01_NC_Naive/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eC++ turi special\u0173 rakta\u017eod\u012f objektams \u2013 <code>class</code>. Pakei\u010diu <code>struct</code> \u012f <code>class</code> ir viskas tur\u0117t\u0173 veikti kaip anks\u010diau.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 tik <code>struct</code> \u2192 <code>class</code> <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 5\n\nclass Stack {       // \u2190 tik \u0161is pakeitimas!\n    char stack[SIZE];\n    int top;\n\n    void init()       { top = 0; }\n    int isEmpty()     { return 0 == top; }\n    int isFull()      { return SIZE == top; }\n    void push(char c) { if (!isFull()) stack[top++] = c; }\n    char pop()        { if (!isEmpty()) return stack[--top]; return '\\0'; }\n};\n\nint main(void) {\n    char c;\n    Stack st1, st2;\n    st1.init();\n    while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n    while (!st1.isEmpty()) putchar(st1.pop());\n    putchar('\\n');\n    st2.init();\n    while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n    while (!st2.isEmpty()) putchar(st2.pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 g++ kompiliavimas\ud83d\udca5 g++ klaidos\ud83d\udd28 clang kompiliavimas\ud83d\udca5 clang klaidos <pre><code>g++ usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp: In function 'int main()':\nusestack.cpp:23:17: error: 'void Stack::init()' is private within this context\n   23 |         st1.init();\n      |         ~~~~~~~~^~\nusestack.cpp:8:14: note: declared private here\n    8 |         void init()       { top = 0; }\n      |              ^~~~\nusestack.cpp:24:28: error: 'int Stack::isFull()' is private within this context\n... (10 klaid\u0173 i\u0161 viso)\n</code></pre> <pre><code>clang usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp:23:13: error: 'init' is a private member of 'Stack'\n   23 |         st1.init();\n      |             ^\nusestack.cpp:8:14: note: implicitly declared private here\n    8 |         void init()       { top = 0; }\n      |              ^\n... (10 klaid\u0173 i\u0161 viso)\n</code></pre> <p>\ud83e\udd14 Pakeit\u0117me tik vien\u0105 \u017eod\u012f \u2013 <code>struct</code> \u2192 <code>class</code>. Kod\u0117l 10 klaid\u0173?</p> Pam\u0105stykite prie\u0161 skaitant toliau... <p><code>struct Stack</code> veik\u0117, <code>class Stack</code> \u2013 ne. Koks formalus skirtumas tarp j\u0173 C++ kalboje?</p> <p>Atsakymas: <code>class</code> pagal nutyl\u0117jim\u0105 slepia visk\u0105</p> <code>struct</code> <code>class</code> Nariai pagal nutyl\u0117jim\u0105 <code>public</code> <code>private</code> <p>Tai vienintelis formalus skirtumas. Bet jo pasekm\u0117 mil\u017eini\u0161ka:</p> <p>Plikas <code>class Stack { void init() {...} }</code> \u2013 <code>init</code> automati\u0161kai <code>private</code>. <code>main()</code> bando kviesti <code>private</code> metod\u0105 \u2013 kompiliatorius blokuoja.</p> <p>Atkreipkite d\u0117mes\u012f \u012f clang \u017einut\u0119: <code>implicitly declared private here</code> \u2013 ne mes para\u0161\u0117me <code>private:</code>, kompiliatorius tai padar\u0117 automati\u0161kai.</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#2-zingsnis-pridedame-public-02_ok","title":"2 \u017eingsnis: Pridedame <code>public:</code> \u2192 <code>02_OK</code>","text":"<p>Failas: <code>13_HIDING_in_CLASS/02_OK/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eMetodai turi b\u016bti pasiekiami i\u0161 i\u0161or\u0117s \u2013 dedu <code>public:</code>. Duomenys tegul lieka <code>private:</code>.\"</p> \ud83d\udcc4 <code>usestack.cpp</code> \u2013 su <code>public:</code>/<code>private:</code> <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 5\n\nclass Stack {\nprivate:                        // \u2190 duomenys pasl\u0117pti\n    char stack[SIZE];\n    int top;\npublic:                         // \u2190 metodai prieinami\n    void init()       { top = 0; }\n    int isEmpty()     { return 0 == top; }\n    int isFull()      { return SIZE == top; }\n    void push(char c) { if (!isFull()) stack[top++] = c; }\n    char pop()        { if (!isEmpty()) return stack[--top]; return '\\0'; }\n};\n\nint main(void) {\n    char c;\n    Stack st1, st2;\n    st1.init();\n    while ((!st1.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st1.push(c);\n    while (!st1.isEmpty()) putchar(st1.pop());\n    putchar('\\n');\n    st2.init();\n    while ((!st2.isFull()) &amp;&amp; ('\\n' != (c = getchar()))) st2.push(c);\n    while (!st2.isEmpty()) putchar(st2.pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f <pre><code>clang usestack.cpp -o app   # \u2705\n./app\n</code></pre> <pre><code>hello\nolleh\nworld\ndlrow\n</code></pre> <p>\u2705 Veikia!</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#3-zingsnis-ataka-03_nc_attack","title":"3 \u017eingsnis: Ataka \u2192 <code>03_NC_Attack</code>","text":"<p>Failas: <code>13_HIDING_in_CLASS/03_NC_Attack/usestack.cpp</code></p> <p>Mintis / ketinimas</p> <p>\u201eI dalyje su C <code>struct</code> ataka pavyko (06 etapas). Patikriname ar \u010dia tas pats...\"</p> \ud83d\udcc4 Atakos kodas <code>main()</code> dalyje <pre><code>// ... (tas pats class Stack su private:/public:)\n\nint main(void) {\n    // ...\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    // ...\n}\n</code></pre> \ud83d\udd28 Kompiliavimas\ud83d\udca5 Klaidos <pre><code>clang usestack.cpp -o app\n</code></pre> <pre><code>usestack.cpp:XX:X: error: 'stack' is a private member of 'Stack'\nusestack.cpp:XX:X: error: 'top' is a private member of 'Stack'\n2 errors generated.\n</code></pre> <p>\u2705 Ataka nepavyko! Kompiliatorius saugo!</p> <p>Paradigminis pokytis \u2013 lyginimas su C</p> C (06 etapas \u2013 <code>struct</code> modulyje) C++ (13 etapas \u2013 <code>class</code>) Ataka \u2705 Pavyko \u2013 <code>st.top = 999;</code> veikia \u274c NC \u2013 kompiliatorius blokuoja Kas saugo? Niekas \u2013 programuotojo atsakomyb\u0117 Kompiliatorius C (07-09 \u2013 opaque pointer) \u2705 Nepavyko \u2013 bet reikia atskiro <code>.c</code> failo Viename faile! Kiek fail\u0173? <code>stack.h</code> + <code>stack.c</code> + <code>user.c</code> Galima viename faile Refleksija: kas dar liko? <p>Turime <code>class</code> su <code>private:</code>/<code>public:</code> \u2013 tai did\u017eiulis \u017eingsnis! Bet <code>init()</code> vis dar kvie\u010diamas rankiniu b\u016bdu \u2013 ar gal\u0117t\u0173 objektas pats pasir\u016bpinti savo inicializacija?</p> <p>\u2192 14 etapas: Konstruktorius \u2013 automatinis <code>init()</code>! \ud83d\ude80</p>"},{"location":"Paskaitos/02/_02_Paskaita_Stack_Evolution_CPP_11_13/#ii-dalies-santrauka-1113-etapai","title":"\ud83c\udfaf II dalies santrauka (11\u201313 etapai)","text":"Nr Etapas \u017dingsniai Atradimas 11 Discovering_CPP_Struct <code>00</code> OK \u2192 <code>01_NC_Naive</code> Funkcija klas\u0117s viduje \u2260 globali funkcija 12 ENCAPSULATING_in_CPP_Struct <code>01_OK</code> \u2192 <code>02_OK_Attack</code> <code>this</code> + encapsulation \u2260 information hiding 13 HIDING_in_CLASS <code>01_NC_Naive</code> \u2192 <code>02_OK</code> \u2192 <code>03_NC_Attack</code> <code>class</code> = <code>private</code> pagal nutyl\u0117jim\u0105; kompiliatorius saugo <p>Klas\u0117s anatomija \u2013 apibendrinimas</p> <pre><code>class Stack {\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nprivate:              // \u2190 prieigos specifikatorius\n    char stack[5];    // \u2190 duomen\u0173 nariai (data members)\n    int top;          //   pasl\u0117pti nuo i\u0161or\u0117s\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npublic:               // \u2190 prieigos specifikatorius\n    void init();      // \u2190 funkcij\u0173 nariai (member functions / metodai)\n    void push(char c);//   prieinami i\u0161 i\u0161or\u0117s\n    char pop();\n    int isEmpty();\n    int isFull();\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n};   // \u2190 kabliata\u0161kis! (skirtingai nuo funkcij\u0173 blok\u0173)\n</code></pre> <p><code>struct</code> vs <code>class</code> C++ kalboje \u2013 formalus skirtumas vienas:</p> Nariai pagal nutyl\u0117jim\u0105 <code>struct</code> <code>public</code> <code>class</code> <code>private</code> <p>Kitas \u017eingsnis: Konstruktorius ir destruktorius \u2013 automatinis lifecycle! \ud83d\ude80</p>"},{"location":"Pratybos/Tvarka/README-assignment/","title":"U[N]: [U\u017eduoties pavadinimas]","text":"<p>B\u016bsena: \u2705 Atlikta Pateikta: 2026-XX-XX</p>"},{"location":"Pratybos/Tvarka/README-assignment/#zingsniai","title":"\ud83d\udcdd \u017dingsniai","text":"\u017dingsnis Direktorija Apra\u0161ymas B\u016bsena 1 <code>01/</code> [Trumpas apra\u0161ymas] \u2705 2 <code>02/</code> [Trumpas apra\u0161ymas] \u2705 3 <code>03/</code> [Trumpas apra\u0161ymas] \u2705 <p>Legenda: \u2705 Atlikta | \ud83d\udd04 Vykdoma | \u23f3 Laukia</p>"},{"location":"Pratybos/Tvarka/README-assignment/#testavimas","title":"\ud83e\uddea Testavimas","text":"<p>Testas 1: [Apra\u0161ymas]</p> <pre><code>Input: [\u012fvestis]\nOutput: [i\u0161vestis]\n</code></pre> <p>\u2705 VEIKIA</p> <p>Testas 2: [Apra\u0161ymas]</p> <pre><code>Input: [\u012fvestis]\nOutput: [i\u0161vestis]\n</code></pre> <p>\u2705 VEIKIA</p>"},{"location":"Pratybos/Tvarka/README-assignment/#izvalgos","title":"\ud83d\udcad \u012e\u017evalgos","text":"<ol> <li>[Pagrindin\u0117 \u012f\u017evalga 1]</li> <li>[Pagrindin\u0117 \u012f\u017evalga 2]</li> <li>[Pagrindin\u0117 \u012f\u017evalga 3]</li> </ol>"},{"location":"Pratybos/Tvarka/README-assignment/#problemos-jei-buvo","title":"\u26a0\ufe0f Problemos (jei buvo)","text":"<p>Problema 1: [Apra\u0161ymas] Sprendimas: [Kaip i\u0161sprend\u0117te]</p>"},{"location":"Pratybos/Tvarka/README-assignment/#kompiliavimas","title":"\ud83d\udce6 Kompiliavimas","text":"<pre><code>cd 03/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/README-assignment/#nuorodos","title":"\ud83d\udd17 Nuorodos","text":"<ul> <li>GitLab commit'ai: [nuoroda \u012f commit history]</li> <li>U\u017eduoties apra\u0161ymas: U[N].md</li> </ul>"},{"location":"Pratybos/Tvarka/README-project/","title":"Objektinis Programavimas C++ (2026)","text":"<p>Studentas: [Vardas Pavard\u0117] Grup\u0117: [Grup\u0117s numeris] GitLab: <code>https://gitlab.mif.vu.lt/[username]/cpp-2026</code></p>"},{"location":"Pratybos/Tvarka/README-project/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md          \u2190 \u0160is failas\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/                \u2190 C++ primityvai\n\u251c\u2500\u2500 U2/                \u2190 IntList (RAII)\n\u251c\u2500\u2500 U3/                \u2190 Kompozicija\n\u251c\u2500\u2500 U4/                \u2190 Deep Copy\n\u251c\u2500\u2500 U5/                \u2190 Operatoriai + Exceptions\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"Pratybos/Tvarka/README-project/#uzduociu-busena","title":"\u2705 U\u017eduo\u010di\u0173 b\u016bsena","text":"U\u017eduotis Tema Terminas B\u016bsena Pateikta U1 C++ primityvai 2026-02-14 \u2705 Atlikta 2026-02-13 U2 IntList (RAII) 2026-02-28 \ud83d\udd04 Vykdoma - U3 Kompozicija 2026-03-14 \u23f3 Laukia - U4 Deep Copy 2026-03-28 \u23f3 Laukia - U5 Operatoriai 2026-04-11 \u23f3 Laukia - <p>Legenda: \u2705 Atlikta | \ud83d\udd04 Vykdoma | \u23f3 Laukia | \u274c Praleista</p>"},{"location":"Pratybos/Tvarka/README-project/#kompiliavimas","title":"\ud83d\udee0\ufe0f Kompiliavimas","text":"<p>Kiekviena u\u017eduotis turi savo Makefile:</p> <pre><code>cd U1/05/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/README-project/#pastabos","title":"\ud83d\udcdd Pastabos","text":"<ul> <li>Commit'ai daromi po kiekvieno \u017eingsnio</li> </ul>"},{"location":"Pratybos/Tvarka/README-project/#klausimai-destytojui","title":"Klausimai d\u0117stytojui","text":""},{"location":"Pratybos/Tvarka/README-step/","title":"U[N]: \u017dingsnis [N] - [Pavadinimas]","text":"<p>PASTABA: \u0160is failas neprivalomas, jei u\u017eduoties \u017eingsni\u0173 atlikimas pakankamai dokumentuotas u\u017eduoties README. Tiesiog - pasibandykite!</p>"},{"location":"Pratybos/Tvarka/README-step/#kas-padaryta","title":"\ud83d\udcdd Kas padaryta","text":"<ul> <li>[x] [U\u017eduotis 1]</li> <li>[x] [U\u017eduotis 2]</li> <li>[ ] [U\u017eduotis 3]</li> </ul>"},{"location":"Pratybos/Tvarka/README-step/#testavimas","title":"\ud83e\uddea Testavimas","text":"<pre><code>Input: [\u012fvestis]\nOutput: [i\u0161vestis]\n</code></pre> <p>\u2705 Veikia | \u23f3 Dar ne | \u274c Neveikia</p>"},{"location":"Pratybos/Tvarka/README-step/#pastabos","title":"\ud83d\udcad Pastabos","text":"<p>[J\u016bs\u0173 pastabos, mintys, problemos]</p>"},{"location":"Pratybos/Tvarka/README-step/#kompiliavimas","title":"\ud83d\udce6 Kompiliavimas","text":"<pre><code>make\n./programa\n</code></pre> <p>Gr\u012f\u017eti: \u2190 U[N] README</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/","title":"U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas","text":"<p>Kursas: Objektinis programavimas C++ Semestras: 2026 pavasaris Versija: 1.0</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#turinys","title":"\ud83d\udccb Turinys","text":"<ol> <li>GitLab projekto suk\u016brimas</li> <li>Projekto strukt\u016bra</li> <li>U\u017eduoties atlikimo workflow</li> <li>Git commit'\u0173 gair\u0117s</li> <li>README.md reikalavimai</li> <li>Pateikimas Moodle</li> <li>Vertinimas</li> <li>DUK</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#gitlab-projekto-sukurimas","title":"\ud83d\ude80 GitLab projekto suk\u016brimas","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#1-zingsnis-sukurti-repo-gitlabe","title":"1 \u017eingsnis: Sukurti repo GitLab'e","text":"<ol> <li>Eikite \u012f fakulteto GitLab: <code>https://git.mif.vu.lt</code></li> <li>Prisijunkite su MIF (!) kredencialais</li> <li>Sukurkite nauj\u0105 projekt\u0105:</li> <li>Project name: <code>cpp-2026</code></li> <li>Visibility: <code>Private</code> (svarbu!)</li> <li>Initialize with README: \u2705 (pa\u017eym\u0117ti)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#2-zingsnis-suteikti-prieiga-destytojui","title":"2 \u017eingsnis: Suteikti prieig\u0105 d\u0117stytojui","text":"<ol> <li>Settings \u2192 Members</li> <li>Add member: <code>[d\u0117stytojo username]</code></li> <li>Role: <code>Maintainer</code></li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#3-zingsnis-clone-repo-i-savo-kompiuteri","title":"3 \u017eingsnis: Clone repo \u012f savo kompiuter\u012f","text":"<pre><code>git clone https://gitlab.mif.vu.lt/[j\u016bs\u0173-username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#pilna-struktura","title":"Pilna strukt\u016bra:","text":"<pre><code>cpp-2026/                    \u2190 GitLab repo\n\u2502\n\u251c\u2500\u2500 README.md                \u2190 Pagrindinis projekto README (PRIVALOMA)\n\u251c\u2500\u2500 .gitignore               \u2190 Git ignoruojami failai (PRIVALOMA)\n\u2502\n\u251c\u2500\u2500 U1/                      \u2190 U\u017eduotis 1\n\u2502   \u251c\u2500\u2500 README.md            \u2190 U\u017eduoties santrauka (PRIVALOMA)\n\u2502   \u251c\u2500\u2500 01/                  \u2190 1 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 02/                  \u2190 2 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 03/                  \u2190 3 \u017eingsnis\n\u2502   \u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.h\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 04/                  \u2190 4 \u017eingsnis\n\u2502   \u2514\u2500\u2500 05/                  \u2190 5 \u017eingsnis (FINAL)\n\u2502\n\u251c\u2500\u2500 U2/                      \u2190 U\u017eduotis 2\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 02/\n\u2502   \u2514\u2500\u2500 03/\n\u2502\n\u251c\u2500\u2500 U3/                      \u2190 U\u017eduotis 3\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 ... (U4-U9)\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#readmemd-hierarchija","title":"README.md hierarchija:","text":"Lygis Failas Turinys Privaloma? Projektas <code>/README.md</code> Bendras projekto apra\u0161ymas, u\u017eduo\u010di\u0173 b\u016bsena \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> U\u017eduoties santrauka, testavimas, pastabos \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> Neb\u016btina \u274c NE"},{"location":"Pratybos/Tvarka/UzduociuGidas/#uzduoties-atlikimo-workflow","title":"\ud83d\udd04 U\u017eduoties atlikimo workflow","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#bendra-schema","title":"Bendra schema:","text":"<pre><code>1. Perskaityti u\u017eduot\u012f (pvz., U1.md)\n   \u2193\n2. Sukurti direktorijas \u017eingsniams (U1/01/, U1/02/, ...)\n   \u2193\n3. Atlikti \u017eingsn\u012f \u2192 compile \u2192 test\n   \u2193\n4. Commit (po kiekvieno \u017eingsnio!)\n   \u2193\n5. Push \u012f GitLab (backup!)\n   \u2193\n6. Kartoti 3-5 kiekvienam \u017eingsniui\n   \u2193\n7. U\u017epildyti U1/README.md\n   \u2193\n8. Final commit + push\n   \u2193\n9. Sukurti archyv\u0105\n   \u2193\n10. Pateikti Moodle\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#detalus-pavyzdys-u1","title":"Detalus pavyzdys (U1):","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#zingsnis-1-sukurti-direktorijas","title":"\u017dingsnis 1: Sukurti direktorijas","text":"<pre><code>cd cpp-2026\nmkdir -p U1/01 U1/02 U1/03 U1/04 U1/05\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#zingsnis-2-atlikti-uzduoties-u1-1-zingsni","title":"\u017dingsnis 2: Atlikti u\u017eduoties U1 1 \u017eingsn\u012f","text":"<pre><code>cd U1/01\n# Ra\u0161yti kod\u0105 (main.cpp)\ng++ main.cpp -o programa\n./programa\n# Testuoti\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#zingsnis-3-commit","title":"\u017dingsnis 3: Commit","text":"<pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#zingsnis-4-atlikti-uzduoties-u1-2-zingsni","title":"\u017dingsnis 4: Atlikti u\u017eduoties U1 2 \u017eingsn\u012f","text":"<pre><code>cd ../02\n# Kopijuoti i\u0161 01/ (jei reikia)\ncp ../01/main.cpp .\n# Modifikuoti kod\u0105\n# ...\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#zingsnis-5-po-visu-zingsniu-uzduoties-readme","title":"\u017dingsnis 5: Po vis\u0173 \u017eingsni\u0173 - u\u017eduoties README","text":"<pre><code>cd U1\n# Sukurti README.md (\u017er. \u0161ablon\u0105 ...)\ngit add README.md\ngit commit -m \"U1: U\u017eduoties README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#git-commitu-gaires","title":"\ud83d\udcdd Git commit'\u0173 gair\u0117s","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#geri-commitai","title":"Geri commit'ai:","text":"<p>\u2705 Po kiekvieno \u017eingsnio <pre><code>git commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit commit -m \"U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra\"\n</code></pre></p> <p>\u2705 Apra\u0161omieji prane\u0161imai <pre><code>git commit -m \"U2: Prid\u0117tas copy constructor su deep copy\"\ngit commit -m \"U3: Pataisyta memory leak destruktoriuje\"\n</code></pre></p> <p>\u2705 Da\u017eni commit'ai (po kiekvienos reik\u0161mingos modifikacijos)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#blogi-commitai","title":"Blogi commit'ai:","text":"<p>\u274c Vienas commit visai u\u017eduo\u010diai <pre><code>git commit -m \"U1 done\"  # Blogai!\n</code></pre></p> <p>\u274c Neapra\u0161omieji prane\u0161imai <pre><code>git commit -m \"fix\"      # Blogai!\ngit commit -m \"asdf\"     # Blogai!\ngit commit -m \"commit\"   # Blogai!\n</code></pre></p> <p>\u274c Reti commit'ai (tik prad\u017eioje ir pabaigoje)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#commit-pranesimu-formatas","title":"Commit prane\u0161im\u0173 formatas:","text":"<pre><code>U[numeris]: [Trumpas apra\u0161ymas]\n\nPavyzd\u017eiai:\n- U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\n- U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra (.h/.cpp)\n- U2: IntList konstruktorius su dynamic allocation\n- U3: Copy constructor - deep copy implementacija\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#readmemd-reikalavimai","title":"\ud83d\udcc4 README.md reikalavimai","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#1-projekto-readme-readmemd-privalomas","title":"1. Projekto README (<code>/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># C++ Objektinis Programavimas (2026)\n\n**Studentas**: Vardas Pavard\u0117  \n**Grup\u0117**: XXXXXX  \n**GitLab**: https://gitlab.mif.vu.lt/[username]/cpp-2026\n\n---\n\n## \ud83d\udcc1 Projekto strukt\u016bra\n\n- **U1/** - C++ primityvai ir funkcij\u0173 moduliai\n- **U2/** - IntList klas\u0117 (RAII)\n- **U3/** - Kompozicija (Langas/Kambarys)\n- *(bus papildoma...)*\n\n---\n\n## \u2705 U\u017eduo\u010di\u0173 b\u016bsena\n\n| U\u017eduotis | B\u016bsena | Terminas | Pateikta |\n|----------|--------|----------|----------|\n| U1 | \u2705 Atlikta | 2026-02-14 | 2026-02-13 |\n| U2 | \ud83d\udd04 Vykdoma | 2026-02-28 | - |\n| U3 | \u23f3 Laukia | 2026-03-14 | - |\n\n---\n\n## \ud83d\udee0\ufe0f Kompiliavimas\n\nKiekviena u\u017eduotis turi savo Makefile:\n\n```bash\ncd U1/05/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#2-uzduoties-readme-u1readmemd-privalomas","title":"2. U\u017eduoties README (<code>/U1/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># U1: C++ Primityvai ir Funkcij\u0173 Moduliai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-XX-XX\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Hello World + masyvas |\n| 2 | `02/` | Bubble sort funkcija |\n| 3 | `03/` | Modulin\u0117 strukt\u016bra (.h/.cpp) |\n| 4 | `04/` | array \u2192 vector&lt;int&gt; |\n| 5 | `05/` | vector&lt;int&gt; \u2192 vector&lt;string&gt; |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (skai\u010diai)**:\n```bash\nInput: 42 17 99 5 0\nOutput: 5 17 42 99\n```bash\n\u2705 VEIKIA\n\n\n**Testas 2 (\u017eod\u017eiai)**:\n```bash\nInput: obuolys bananas citrina -\nOutput: bananas citrina obuolys\n```bash\n\u2705 VEIKIA\n\n\n---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Modulin\u0117 strukt\u016bra - `.h`/.`cpp` separacija patogu\n2. Vector daug lankstesnis u\u017e masyv\u0105 (dinaminis dydis)\n3. Tas pats algoritmas veikia su int ir string!\n\n---\n\n## \u26a0\ufe0f Problemos (jei buvo)\n\n**Problema 1**: Makefile TAB vs spaces  \n**Sprendimas**: Pakeisti spaces \u012f TAB simbolius\n\n---\n\n## \ud83d\udce6 Kompiliavimas\n\n```bash\ncd 05/\nmake\n./programa\n</code></pre> <p>Minimumas (jei tingite): - \u2705 \u017dingsni\u0173 lentel\u0117 - \u2705 Bent 1-2 testai - \u2705 Kompiliavimo instrukcijos</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#3-zingsnio-readme-u101readmemd-neprivalomas","title":"3. \u017dingsnio README (<code>/U1/01/README.md</code>) - NEPRIVALOMAS","text":"<p>Jei norite, galite prid\u0117ti trumpas pastabas kiekviename \u017eingsnyje!</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#pateikimas-moodle","title":"\ud83d\udce6 Pateikimas Moodle","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#1-budas-git-archive-rekomenduojama","title":"1 b\u016bdas: Git archive (rekomenduojama)","text":"<pre><code>cd cpp-2026\n\n# Sukurti archyv\u0105 tik su U1 u\u017eduotimi\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/\n\n# ARBA visa repo archyvas\ngit archive --format=zip --output=cpp2026_VardasPavarde.zip HEAD\n</code></pre> <p>Pliusai:  - \u2705 Archyvuoja tik commit'intus failus (ne \"junk\" failus) - \u2705 Automati\u0161kai ignoruoja <code>.o</code>, <code>programa</code>, ir kt.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#2-budas-rankinis-zip","title":"2 b\u016bdas: Rankinis zip","text":"<pre><code>cd cpp-2026\n\n# I\u0161valyti compiled failus\ncd U1/05\nmake clean\ncd ../..\n\n# Sukurti archyv\u0105\nzip -r U1_VardasPavarde.zip U1/ README.md .gitignore\n</code></pre> <p>Minusai: - \u26a0\ufe0f Reikia rankiniu b\u016bdu i\u0161valyti - \u26a0\ufe0f Galite \u012ftraukti \"junk\" failus</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#archyvo-vardas","title":"Archyvo vardas:","text":"<pre><code>U[numeris]_VardasPavarde.zip\n\nPavyzd\u017eiai:\n- U1_JonasJonaitis.zip\n- U2_PetrasPetraitis.zip\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#kas-turi-buti-archyve","title":"Kas turi b\u016bti archyve:","text":"<p>\u2705 Privaloma: - <code>/U1/</code> direktorija su visais \u017eingsniais - <code>/U1/README.md</code> - <code>/README.md</code> (projekto root README) - <code>/.gitignore</code></p> <p>\u274c Neturi b\u016bti: - <code>*.o</code> failai (compiled object files) - Executable failai (<code>programa</code>, <code>a.out</code>, etc.) - Editor junk (<code>.vscode/</code>, <code>.idea/</code>, <code>*~</code>)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#moodle-pateikimo-workflow","title":"Moodle pateikimo workflow:","text":"<ol> <li>Sukurti archyv\u0105 (\u017er. auk\u0161\u010diau)</li> <li>Eiti \u012f Moodle \u2192 C++ kursas \u2192 U\u017eduotis U1</li> <li>Upload fail\u0105: <code>U1_VardasPavarde.zip</code></li> <li>Prid\u0117ti GitLab URL (comment/text field):    <pre><code>GitLab repo: https://gitlab.mif.vu.lt/[username]/cpp-2026\nCommit hash: abc123def456\n</code></pre></li> <li>Submit</li> </ol> <p>Terminas: \u017di\u016br\u0117kite u\u017eduoties apra\u0161yme (pvz., U1.md)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#duk","title":"\u2753 DUK","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ar-galiu-naudoti-branchus-vietoj-subdirektoriju","title":"K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173?","text":"<p>A: Taip, galite, bet neprivaloma. </p> <p>Pavyzdys su branch'ais: <pre><code>git checkout -b u1-step1\n# ... darbas ...\ngit commit -m \"U1: 1 \u017eingsnis\"\n\ngit checkout -b u1-step2\n# ... darbas ...\ngit commit -m \"U1: 2 \u017eingsnis\"\n\n# Galutinis merge \u012f main\ngit checkout main\ngit merge u1-step5\n</code></pre></p> <p>Bet subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s ir labiau atitinka paskait\u0173 med\u017eiag\u0105 (Stack Evolution stilius).</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ar-reikia-makefile-kiekviename-zingsnyje","title":"K: Ar reikia Makefile kiekviename \u017eingsnyje?","text":"<p>A: Ne, tik nuo 3 \u017eingsnio (kai turite kelis <code>.cpp</code> failus).</p> <ul> <li>\u017dingsniai 1-2: <code>g++ main.cpp -o programa</code> pakanka</li> <li>\u017dingsniai 3-5: Makefile rekomenduojamas (daug fail\u0173)</li> </ul>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ar-galiu-naudoti-ide-vs-code-clion","title":"K: Ar galiu naudoti IDE (VS Code, CLion)?","text":"<p>A: Taip, bet: - \u2705 \u012etraukite <code>.gitignore</code> ignoruoti IDE failus - \u2705 Programa turi kompiliuotis su Makefile (ne tik IDE) - \u274c Ne\u012ftraukite <code>.vscode/</code>, <code>.idea/</code> \u012f repo</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ka-daryti-jei-pamirsau-commitinti","title":"K: K\u0105 daryti, jei pamir\u0161au commit'inti?","text":"<p>A: Commit'inkite dabar!</p> <pre><code># Jei jau padar\u0117te kelis \u017eingsnius be commit'\u0173:\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis (late commit)\"\n\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis (late commit)\"\n</code></pre> <p>Geriau v\u0117liau nei niekada! Bet ateityje commit'inkite da\u017enai.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ar-senasis-kodas-turi-buti-uzkomentuotas-ar-istrinti","title":"K: Ar senasis kodas turi b\u016bti u\u017ekomentuotas ar i\u0161trinti?","text":"<p>A: Priklauso nuo u\u017eduoties:</p> <ul> <li>U1: U\u017ekomentuoti (\u017er. U1.md reikalavimus)</li> <li>U2-U9: I\u0161trinti (senasis kodas - tai praeit\u0173 \u017eingsni\u0173 direktorijos)</li> </ul> <p>Git saugo vis\u0105 istorij\u0105, tod\u0117l galite i\u0161trinti sen\u0105 kod\u0105 - jis vis tiek matomas commit'uose!</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ar-gitignore-privalomas","title":"K: Ar <code>.gitignore</code> privalomas?","text":"<p>A: Taip! \u012etraukite \u0161\u012f minimal\u0173 <code>.gitignore</code>:</p> <pre><code># Compiled files\n*.o\n*.out\nprograma\na.out\n\n# Editor files\n*~\n.vscode/\n.idea/\n*.swp\n\n# OS files\n.DS_Store\nThumbs.db\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ka-daryti-jei-gitlab-permission-denied","title":"K: K\u0105 daryti, jei GitLab \"permission denied\"?","text":"<p>A: Patikrinkite SSH raktus:</p> <pre><code># Sugeneruoti SSH rakt\u0105 (jei neturite)\nssh-keygen -t ed25519 -C \"your.email@mif.vu.lt\"\n\n# Nukopijuoti public key\ncat ~/.ssh/id_ed25519.pub\n\n# \u012etraukti \u012f GitLab:\n# Settings \u2192 SSH Keys \u2192 Add key\n</code></pre> <p>Arba naudokite HTTPS: <pre><code>git clone https://gitlab.mif.vu.lt/[username]/cpp-2026.git\n</code></pre></p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-ar-galiu-dirbti-grupeje","title":"K: Ar galiu dirbti grup\u0117je?","text":"<p>A: Ne, kiekvienas studentas turi savo repo.</p> <p>Bet galite: - \u2705 Diskutuoti id\u0117jas - \u2705 Pad\u0117ti debug'inti (neduoti kodo!) - \u274c Kopijuoti kod\u0105 (plagiatas!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-kiek-laiko-uztrunka-uzduotis","title":"K: Kiek laiko u\u017etrunka u\u017eduotis?","text":"<p>A: Priklauso nuo u\u017eduoties ir j\u016bs\u0173 patirties:</p> <ul> <li>U1: 3-5 valandos (pradedantiesiems), 2-3 val (patyrusiems)</li> <li>U2-U3: 4-6 valandos</li> <li>U4-U7: 5-8 valandos</li> <li>U8-U9: 8-12 valand\u0173 (projektas)</li> </ul> <p>Patariu: Prad\u0117ti anks\u010diau, nelaukti paskutin\u0117s dienos! \ud83d\ude0a</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#k-i-ka-kreiptis-pagalbos","title":"K: \u012e k\u0105 kreiptis pagalbos?","text":"<p>A: 1. Pirmiausia: Perskaityti u\u017eduoties apra\u0161ym\u0105 (U1.md, U2.md, ...) 2. Antra: Pa\u017ei\u016br\u0117ti Stack Overflow, cppreference.com 3. Tre\u010dia: Klausti d\u0117stytojo (auditorijoje, Teams arba email) 4. Paskutinis b\u016bdas: Klausti kolegos (bet ne kopijuoti kodo!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>GitLab dokumentacija: https://docs.gitlab.com/</li> <li>Git tutorial: https://git-scm.com/book/en/v2</li> <li>Markdown sintaks\u0117: https://www.markdownguide.org/</li> <li>Makefile tutorial: https://makefiletutorial.com/</li> </ul>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/","title":"U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas","text":"<p>Kursas: Objektinis programavimas C++ Semestras: 2026 pavasaris Versija: 1.1</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#turinys","title":"\ud83d\udccb Turinys","text":"<ol> <li>GitLab projekto suk\u016brimas</li> <li>Projekto strukt\u016bra</li> <li>U\u017eduoties atlikimo workflow</li> <li>Git commit'\u0173 gair\u0117s</li> <li>README.md reikalavimai</li> <li>Pateikimas Moodle</li> <li>Vertinimas</li> <li>DUK</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#gitlab-projekto-sukurimas","title":"\ud83d\ude80 GitLab projekto suk\u016brimas","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#1-zingsnis-sukurti-repo-gitlabe","title":"1 \u017eingsnis: Sukurti repo GitLab'e","text":"<ol> <li>Eikite \u012f fakulteto GitLab: <code>https://git.mif.vu.lt</code></li> <li>Prisijunkite su VU kredencialais</li> <li>Sukurkite nauj\u0105 projekt\u0105:</li> <li>Project name: <code>cpp-2026</code></li> <li>Visibility: <code>Private</code></li> <li>Initialize with README: \u2705 (pa\u017eym\u0117ti)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#2-zingsnis-suteikti-prieiga-destytojui","title":"2 \u017eingsnis: Suteikti prieig\u0105 d\u0117stytojui","text":"<ol> <li>Manage \u2192 Members</li> <li>Add member: <code>Viktoras Golubevas</code></li> <li>Role: <code>Maintainer</code></li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#3-zingsnis-clone-repo-i-savo-kompiuteri","title":"3 \u017eingsnis: Clone repo \u012f savo kompiuter\u012f","text":"<pre><code>git clone https://git.mif.vu.lt/[j\u016bs\u0173-username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#pavyzdine-struktura","title":"Pavyzdin\u0117 strukt\u016bra:","text":"<pre><code>cpp-2026/                    \u2190 GitLab repo\n\u2502\n\u251c\u2500\u2500 README.md                \u2190 Pagrindinis projekto README (PRIVALOMA)\n\u251c\u2500\u2500 .gitignore               \u2190 Git ignoruojami failai (PRIVALOMA)\n\u2502\n\u251c\u2500\u2500 U1/                      \u2190 U\u017eduotis 1\n\u2502   \u251c\u2500\u2500 README.md            \u2190 U\u017eduoties santrauka (PRIVALOMA)\n\u2502   \u251c\u2500\u2500 01/                  \u2190 1 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 02/                  \u2190 2 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 03/                  \u2190 3 \u017eingsnis\n\u2502   \u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.h\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 04/                  \u2190 4 \u017eingsnis\n\u2502   \u2514\u2500\u2500 05/                  \u2190 5 \u017eingsnis\n\u2502\n\u251c\u2500\u2500 U2/                      \u2190 U\u017eduotis 2\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 02/\n\u2502   \u2514\u2500\u2500 03/\n\u2502\n\u251c\u2500\u2500 U3/                      \u2190 U\u017eduotis 3\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 ... (U4-U9)\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#readmemd-hierarchija","title":"README.md hierarchija:","text":"Lygis Failas Turinys Privaloma? Projektas <code>/README.md</code> Bendras projekto apra\u0161ymas, u\u017eduo\u010di\u0173 b\u016bsena \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> U\u017eduoties santrauka, testavimas, pastabos \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> Neb\u016btina \u274c NE"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#uzduoties-atlikimo-workflow","title":"\ud83d\udd04 U\u017eduoties atlikimo workflow","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#bendra-schema","title":"Bendra schema:","text":"<pre><code>1. Perskaityti u\u017eduot\u012f (pvz., U1.md)\n   \u2193\n2. Sukurti direktorijas \u017eingsniams (U1/01/, U1/02/, ...)\n   \u2193\n3. Atlikti \u017eingsn\u012f \u2192 compile \u2192 test\n   \u2193\n4. Commit (po kiekvieno \u017eingsnio!)\n   \u2193\n5. Push \u012f GitLab (backup!)\n   \u2193\n6. Kartoti 3-5 kiekvienam \u017eingsniui\n   \u2193\n7. U\u017epildyti U1/README.md\n   \u2193\n8. Final commit + push\n   \u2193\n9. Sukurti archyv\u0105\n   \u2193\n10. Pateikti Moodle\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#detalus-pavyzdys-u1","title":"Detalus pavyzdys (U1):","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#zingsnis-1-sukurti-direktorijas","title":"\u017dingsnis 1: Sukurti direktorijas","text":"<pre><code>cd cpp-2026\nmkdir -p U1/01 U1/02 U1/03 U1/04 U1/05\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#zingsnis-2-atlikti-1-uzduoties-zingsni","title":"\u017dingsnis 2: Atlikti 1 u\u017eduoties \u017eingsn\u012f","text":"<pre><code>cd U1/01\n# Ra\u0161yti kod\u0105 (main.cpp)\ng++ main.cpp -o programa\n./programa\n# Testuoti\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#zingsnis-3-commit","title":"\u017dingsnis 3: Commit","text":"<pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#zingsnis-4-atlikti-2-uzduoties-zingsni","title":"\u017dingsnis 4: Atlikti 2 u\u017eduoties \u017eingsn\u012f","text":"<pre><code>cd ../02\n# Kopijuoti i\u0161 01/ (jei reikia)\ncp ../01/main.cpp .\n# Modifikuoti kod\u0105\n# ...\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#zingsnis-5-po-visu-zingsniu-readme","title":"\u017dingsnis 5: Po vis\u0173 \u017eingsni\u0173 - README","text":"<pre><code>cd U1\n# Sukurti README.md (\u017er. \u0161ablon\u0105 \u017eemiau)\ngit add README.md\ngit commit -m \"U1: U\u017eduoties README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#git-commitu-gaires","title":"\ud83d\udcdd Git commit'\u0173 gair\u0117s","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#geri-commitai","title":"Geri commit'ai:","text":"<p>\u2705 Po kiekvieno \u017eingsnio <pre><code>git commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit commit -m \"U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra\"\n</code></pre></p> <p>\u2705 Apra\u0161omieji prane\u0161imai <pre><code>git commit -m \"U2: Prid\u0117tas copy constructor su deep copy\"\ngit commit -m \"U3: Pataisyta memory leak destruktoriuje\"\n</code></pre></p> <p>\u2705 Da\u017eni commit'ai (po kiekvienos reik\u0161mingos modifikacijos)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#blogi-commitai","title":"Blogi commit'ai:","text":"<p>\u274c Vienas commit visai u\u017eduo\u010diai <pre><code>git commit -m \"U1 done\"  # Blogai!\n</code></pre></p> <p>\u274c Neapra\u0161omieji prane\u0161imai <pre><code>git commit -m \"fix\"      # Blogai!\ngit commit -m \"asdf\"     # Blogai!\ngit commit -m \"commit\"   # Blogai!\n</code></pre></p> <p>\u274c Reti commit'ai (tik prad\u017eioje ir pabaigoje)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#commit-pranesimu-formatas","title":"Commit prane\u0161im\u0173 formatas:","text":"<pre><code>U[numeris]: [Trumpas apra\u0161ymas]\n\nPavyzd\u017eiai:\n- U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\n- U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra (.h/.cpp)\n- U2: IntList konstruktorius su dynamic allocation\n- U3: Copy constructor - deep copy implementacija\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#readmemd-reikalavimai","title":"\ud83d\udcc4 README.md reikalavimai","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#1-projekto-readme-readmemd-privalomas","title":"1. Projekto README (<code>/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># C++ Objektinis Programavimas (2026)\n\n**Studentas**: Vardas Pavard\u0117  \n**Grup\u0117**: XXXXXX  \n**GitLab**: https://gitlab.mif.vu.lt/[username]/cpp-2026\n\n---\n\n## \ud83d\udcc1 Projekto strukt\u016bra\n\n- **U1/** - C++ primityvai ir funkcij\u0173 moduliai\n- **U2/** - IntList klas\u0117 (RAII)\n- **U3/** - Kompozicija (Langas/Kambarys)\n- *(bus papildoma...)*\n\n---\n\n## \u2705 U\u017eduo\u010di\u0173 b\u016bsena\n\n| U\u017eduotis | B\u016bsena | Terminas | Pateikta |\n|----------|--------|----------|----------|\n| U1 | \u2705 Atlikta | 2026-02-14 | 2026-02-13 |\n| U2 | \ud83d\udd04 Vykdoma | 2026-02-28 | - |\n| U3 | \u23f3 Laukia | 2026-03-14 | - |\n\n---\n\n## \ud83d\udee0\ufe0f Kompiliavimas\n\nKiekviena u\u017eduotis turi savo Makefile:\n\n```bash\ncd U1/05/\nmake\n./programa\n```bash\n\n---\n\n## \ud83d\udcdd Pastabos\n\n- Commit'ai buvo daromi po kiekvieno \u017eingsnio\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#2-uzduoties-readme-u1readmemd-privalomas","title":"2. U\u017eduoties README (<code>/U1/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># U1: C++ Primityvai ir Funkcij\u0173 Moduliai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-02-10\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Hello World + masyvas |\n| 2 | `02/` | Bubble sort funkcija |\n| 3 | `03/` | Modulin\u0117 strukt\u016bra (.h/.cpp) |\n| 4 | `04/` | array \u2192 vector&lt;int&gt; |\n| 5 | `05/` | vector&lt;int&gt; \u2192 vector&lt;string&gt; |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (skai\u010diai)**:\n```txt\nInput: 42 17 99 5 0\nOutput: 5 17 42 99\n\u2705 VEIKIA\n```txt\n\n**Testas 2 (\u017eod\u017eiai)**:\n```txt\nInput: obuolys bananas citrina -\nOutput: bananas citrina obuolys\n\u2705 VEIKIA\n```txt\n\n---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos (jei turite)\n\n1. Vector daug lankstesnis u\u017e masyv\u0105 (dinaminis dydis)\n2. Tas pats algoritmas veikia su int ir string!\n\n---\n\n## \u26a0\ufe0f Problemos (jei buvo)\n\n*(Neprivaloma, bet naudinga)*\n\n**Problema 1**: Makefile TAB vs spaces  \n**Sprendimas**: Pakeisti spaces \u012f TAB simbolius\n\n---\n\n## \ud83d\udce6 Kompiliavimas\n\n```bash\ncd 05/\nmake\n./programa\n```bash\n</code></pre> <p>Minimumas (jei tingite): - \u2705 \u017dingsni\u0173 lentel\u0117 - \u2705 Bent 1 testas - \u2705 Kompiliavimo instrukcijos</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#pateikimas-moodle","title":"\ud83d\udce6 Pateikimas Moodle","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#1-budas-git-archive-rekomenduojama","title":"1 b\u016bdas: Git archive (rekomenduojama)","text":"<pre><code>cd cpp-2026\n\n# Sukurti archyv\u0105 tik su U1 u\u017eduotimi\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/\n\n# ARBA visa repo archyvas\ngit archive --format=zip --output=cpp2026_VardasPavarde.zip HEAD\n</code></pre> <p>Pliusai:  - \u2705 Archyvuoja tik commit'intus failus (ne \"junk\" failus) - \u2705 Automati\u0161kai ignoruoja <code>.o</code>, <code>programa</code>, ir kt.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#2-budas-rankinis-zip","title":"2 b\u016bdas: Rankinis zip","text":"<pre><code>cd cpp-2026\n\n# I\u0161valyti compiled failus\ncd U1/05\nmake clean\ncd ../..\n\n# Sukurti archyv\u0105\nzip -r U1_VardasPavarde.zip U1/ README.md .gitignore\n</code></pre> <p>Minusai: - \u26a0\ufe0f Reikia rankiniu b\u016bdu i\u0161valyti - \u26a0\ufe0f Galite \u012ftraukti \"junk\" failus</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#archyvo-vardas","title":"Archyvo vardas:","text":"<p>U[numeris]_VardasPavarde.zip</p> <p>Pavyzd\u017eiai: - U1_JonasJonaitis.zip - U2_PetrasPetraitis.zip</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#kas-turi-buti-archyve","title":"Kas turi b\u016bti archyve:","text":"<p>\u2705 Privaloma: - <code>/U1/</code> direktorija su visais \u017eingsniais - <code>/U1/README.md</code> - <code>/README.md</code> (projekto root README) - <code>/.gitignore</code></p> <p>\u274c Neturi b\u016bti: - <code>*.o</code> failai (compiled object files) - Executable failai (<code>programa</code>, <code>a.out</code>, etc.) - Editor junk (<code>.vscode/</code>, <code>.idea/</code>, <code>*~</code>)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#moodle-pateikimo-workflow","title":"Moodle pateikimo workflow:","text":"<ol> <li>Sukurti archyv\u0105 (\u017er. auk\u0161\u010diau)</li> <li>Eiti \u012f Moodle \u2192 C++ kursas \u2192 U\u017eduotis U1</li> <li>Upload fail\u0105: <code>U1_VardasPavarde.zip</code></li> <li>Prid\u0117ti GitLab URL (comment/text field):</li> </ol> <p><pre><code>GitLab repo: https://git.mif.vu.lt/[username]/cpp-2026\nCommit hash: abc123def456\n</code></pre> 5. Submit</p> <p>Terminas: \u017di\u016br\u0117kite u\u017eduoties apra\u0161yme (pvz., U1.md)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#duk","title":"\u2753 DUK","text":""},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ar-galiu-naudoti-branchus-vietoj-subdirektoriju","title":"K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173?","text":"<p>A: Taip, galite, bet neprivaloma. </p> <p>Pavyzdys su branch'ais: <pre><code>git checkout -b u1-step1\n# ... darbas ...\ngit commit -m \"U1: 1 \u017eingsnis\"\n\ngit checkout -b u1-step2\n# ... darbas ...\ngit commit -m \"U1: 2 \u017eingsnis\"\n\n# Galutinis merge \u012f main\ngit checkout main\ngit merge u1-step5\n</code></pre></p> <p>Bet subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s ir labiau atitinka paskait\u0173 med\u017eiag\u0105 (D\u0117stytojo \"Stack Evolution\" stilius mokomojoje repo).</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ar-reikia-makefile-kiekviename-zingsnyje","title":"K: Ar reikia Makefile kiekviename \u017eingsnyje?","text":"<p>A: Ne, tik nuo 3 \u017eingsnio (kai turite kelis <code>.cpp</code> failus).</p> <ul> <li>\u017dingsniai 1-2: <code>g++ main.cpp -o programa</code> pakanka</li> <li>\u017dingsniai 3-5: Makefile rekomenduojamas (daug fail\u0173)</li> </ul>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ar-galiu-naudoti-ide-vs-code-clion","title":"K: Ar galiu naudoti IDE (VS Code, CLion)?","text":"<p>A: Taip, bet: - \u2705 \u012etraukite <code>.gitignore</code> ignoruoti IDE failus - \u2705 Programa turi kompiliuotis su Makefile (ne tik IDE) - \u274c Ne\u012ftraukite <code>.vscode/</code>, <code>.idea/</code> \u012f repo</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ka-daryti-jei-pamirsau-commitinti","title":"K: K\u0105 daryti, jei pamir\u0161au commit'inti?","text":"<p>A: Commit'inkite dabar!</p> <pre><code># Jei jau padar\u0117te kelis \u017eingsnius be commit'\u0173:\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis (late commit)\"\n\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis (late commit)\"\n</code></pre> <p>Geriau v\u0117liau nei niekada! Bet ateityje commit'inkite da\u017enai.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ar-senasis-kodas-turi-buti-uzkomentuotas-ar-istrinti","title":"K: Ar senasis kodas turi b\u016bti u\u017ekomentuotas ar i\u0161trinti?","text":"<p>A: Priklauso nuo u\u017eduoties:</p> <ul> <li>U1: U\u017ekomentuoti (\u017er. U1.md reikalavimus)</li> <li>U2-U9: I\u0161trinti (senasis kodas - tai praeit\u0173 \u017eingsni\u0173 direktorijos)</li> </ul> <p>Git saugo vis\u0105 istorij\u0105, tod\u0117l galite i\u0161trinti sen\u0105 kod\u0105 - jis vis tiek matomas commit'uose!</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ar-gitignore-privalomas","title":"K: Ar <code>.gitignore</code> privalomas?","text":"<p>A: Taip! \u012etraukite \u0161\u012f minimal\u0173 <code>.gitignore</code>:</p> <pre><code># Compiled files\n*.o\n*.out\nprograma\na.out\n\n# Editor files\n*~\n.vscode/\n.idea/\n*.swp\n\n# OS files\n.DS_Store\nThumbs.db\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ka-daryti-jei-gitlab-permission-denied","title":"K: K\u0105 daryti, jei GitLab \"permission denied\"?","text":"<p>A: Patikrinkite SSH raktus:</p> <pre><code># Sugeneruoti SSH rakt\u0105 (jei neturite)\nssh-keygen -t ed25519 -C \"your.email@mif.vu.lt\"\n\n# Nukopijuoti public key\ncat ~/.ssh/id_ed25519.pub\n\n# \u012etraukti \u012f GitLab:\n# Settings \u2192 SSH Keys \u2192 Add key\n</code></pre> <p>Arba naudokite HTTPS: <pre><code>git clone https://gitlab.mif.vu.lt/[username]/cpp-2026.git\n</code></pre></p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-ar-galiu-dirbti-grupeje","title":"K: Ar galiu dirbti grup\u0117je?","text":"<p>A: Ne, kiekvienas studentas turi savo repo.</p> <p>Bet galite: - \u2705 Diskutuoti id\u0117jas - \u2705 Pad\u0117ti debug'inti (ne duoti kodo!) - \u274c Kopijuoti kod\u0105 (plagiatas!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-kiek-laiko-uztrunka-uzduotis","title":"K: Kiek laiko u\u017etrunka u\u017eduotis?","text":"<p>A: Priklauso nuo u\u017eduoties ir j\u016bs\u0173 patirties:</p> <ul> <li>U1: 3-5 valandos (pradedantiesiems), 2-3 val (patyrusiems)</li> <li>U2-U3: 4-6 valandos</li> <li>U4-U7: 5-8 valandos</li> <li>U8-U9: 8-12 valand\u0173 (projektas)</li> </ul> <p>Patariu: Prad\u0117ti anks\u010diau, ne laukti paskutin\u0117s dienos! \ud83d\ude0a</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#k-kam-kreiptis-pagalbos","title":"K: Kam kreiptis pagalbos?","text":"<p>A: 1. Pirmiausia: Perskaityti u\u017eduoties apra\u0161ym\u0105 (U1.md, U2.md, ...) 2. Antra: Pa\u017ei\u016br\u0117ti Stack Overflow, cppreference.com 3. Tre\u010dia: Klausti d\u0117stytojo (Moodle arba email) 4. Paskutinis b\u016bdas: Klausti kolegos (bet ne kopijuoti kod\u0105!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidas_1_1/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>GitLab dokumentacija: https://docs.gitlab.com/</li> <li>Git tutorial: https://git-scm.com/book/en/v2</li> <li>Markdown sintaks\u0117: https://www.markdownguide.org/</li> <li>C++ reference: https://en.cppreference.com/</li> <li>Makefile tutorial: https://makefiletutorial.com/</li> </ul>"},{"location":"Pratybos/U%C5%BEduotys/U1/","title":"U1: C++ Primityvai ir Funkcij\u0173 Moduliai","text":"<p>Savait\u0117s: 1-2 Svoris: 1 balas Terminas: Savait\u0117s 2 pabaiga</p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>SVARBU: Jei dar nesuk\u016br\u0117te GitLab projekto, pirmiausia perskaitykite: \ud83d\udc49 U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas</p> <p>Ten rasite: - GitLab projekto suk\u016brimo instrukcijas - Projekto strukt\u016br\u0105 - Git workflow gaires - README.md \u0161ablonus - Pateikimo \u012f Moodle proces\u0105</p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>\u012esiva\u017eiuoti su C++ sintakse, i\u0161mokti dirbti su masyvais, konteineriais ir funkcijomis. Suprasti modulin\u0119 program\u0173 strukt\u016br\u0105.</p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Naudoti C++ \u012fvesties/i\u0161vesties srautus (<code>cin</code>, <code>cout</code>)</li> <li>\u2705 Dirbti su masyvais ir <code>vector</code> konteineriais</li> <li>\u2705 Ra\u0161yti ir kviesti funkcijas</li> <li>\u2705 Organizuoti kod\u0105 \u012f keli\u0173 fail\u0173 strukt\u016br\u0105 (<code>.h</code>/<code>.cpp</code>)</li> <li>\u2705 Kompiliuoti program\u0105 i\u0161 keli\u0173 fail\u0173</li> </ul>"},{"location":"Pratybos/U%C5%BEduotys/U1/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/U%C5%BEduotys/U1/#1-zingsnis-hello-c-ir-masyvu-ivestis","title":"1 \u017eingsnis. \"Hello C++\" ir masyv\u0173 \u012fvestis","text":"<p>Reikalavimai: 1. Para\u0161ykite program\u0105, kuri:    - I\u0161veda \"Hello, C++!\" \u012f konsol\u0119    - Leid\u017eia vartotojui \u012fvesti sveikus skai\u010dius    - Talpina skai\u010dius \u012f fiksuoto dyd\u017eio masyv\u0105 (pvz., 100 element\u0173)    - Baigia \u012fvedim\u0105, kai vartotojas \u012fveda <code>0</code>    - Atspausdina visus \u012fvestus skai\u010dius</p> <p>Technikos: - Naudokite <code>cout</code> i\u0161vedimui - Naudokite <code>cin</code> \u012fvedimui - Naudokite <code>int</code> tipo masyv\u0105: <code>int skaiciai[100];</code> - Saugokite \u012fvest\u0173 skai\u010di\u0173 kiek\u012f atskirame kintamajame</p> <p>Pavyzdys: <pre><code>Hello, C++!\n\u012eveskite sveikus skai\u010dius (0 - baigti):\n42\n17\n99\n0\n\u012evesti skai\u010diai: 42 17 99\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#2-zingsnis-bubble-sort-funkcija","title":"2 \u017eingsnis. Bubble sort funkcija","text":"<p>Reikalavimai: 1. Para\u0161ykite funkcij\u0105 <code>rusiuotiMasyva()</code>, kuri:    - Priima masyv\u0105 ir jo dyd\u012f    - Sur\u016b\u0161iuoja masyvo elementus nuo ma\u017eiausio iki did\u017eiausio    - Naudoja Bubble sort algoritm\u0105</p> <ol> <li>Programos <code>main()</code> funkcijoje:</li> <li>I\u0161kvieskite r\u016b\u0161iavimo funkcij\u0105</li> <li>Atspausdinkite sur\u016b\u0161iuotus skai\u010dius</li> </ol> <p>Technikos: - Funkcijos deklaracija: <code>void rusiuotiMasyva(int masyvas[], int dydis);</code> - Bubble sort: lyginkite gretimus elementus ir keiskite vietomis</p> <p>Pavyzdys: <pre><code>\u012evesti skai\u010diai: 42 17 99\nSur\u016b\u0161iuoti skai\u010diai: 17 42 99\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#3-zingsnis-moduline-struktura-h-cpp","title":"3 \u017eingsnis. Modulin\u0117 strukt\u016bra (.h + .cpp)","text":"<p>Reikalavimai: 1. Sukurkite 3 failus direktorijoje <code>U1/03/</code>:    - <code>main.cpp</code> - pagrindin\u0117 programa (tik <code>main()</code> funkcija)    - <code>rusiavimas.h</code> - funkcij\u0173 deklaracijos    - <code>rusiavimas.cpp</code> - funkcij\u0173 implementacijos</p> <ol> <li><code>rusiavimas.h</code> turi tur\u0117ti:</li> <li>Header guard (<code>#ifndef</code>, <code>#define</code>, <code>#endif</code>)</li> <li>Funkcijos <code>rusiuotiMasyva()</code> deklaracij\u0105</li> <li> <p>Funkcijos <code>spausdintiMasyva()</code> deklaracij\u0105 (nauja!)</p> </li> <li> <p><code>rusiavimas.cpp</code> turi tur\u0117ti:</p> </li> <li><code>#include \"rusiavimas.h\"</code></li> <li> <p>Funkcij\u0173 implementacijas</p> </li> <li> <p><code>main.cpp</code> turi tur\u0117ti:</p> </li> <li><code>#include \"rusiavimas.h\"</code></li> <li>Tik <code>main()</code> funkcij\u0105</li> </ol> <p>Kompiliacija: <pre><code>cd U1/03/\ng++ -c main.cpp\ng++ -c rusiavimas.cpp\ng++ main.o rusiavimas.o -o programa\n./programa\n</code></pre></p> <p>Arba naudojant Makefile (rekomenduojama).</p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#4-zingsnis-evoliucija-array-vectorint","title":"4 \u017eingsnis. Evoliucija: array \u2192 vector\\&lt;int&gt;","text":"<p>Reikalavimai: 1. Pakeiskite masyv\u0105 <code>int skaiciai[100]</code> \u012f <code>vector&lt;int&gt; skaiciai</code> 2. Vietoj <code>skaiciai[kiekis++] = x</code> naudokite <code>skaiciai.push_back(x)</code> 3. Vektoriaus dyd\u012f gaukite su <code>skaiciai.size()</code> 4. Adaptuokite r\u016b\u0161iavimo funkcij\u0105 dirbti su <code>vector&lt;int&gt;</code></p> <p>SVARBU:  - U\u017ekomentuokite sen\u0105 kod\u0105 su masyvais, bet palikite j\u012f matytis faile - Tai leis d\u0117stytojui \u012fsitikinti, kad atlikote visus \u017eingsnius</p> <p>Technikos: - <code>#include &lt;vector&gt;</code> - <code>vector&lt;int&gt;</code> vietoj <code>int[]</code> - Funkcija gali b\u016bti: <code>void rusiuotiVektoriu(vector&lt;int&gt;&amp; skaiciai)</code> - Perduokite vektori\u0173 per nuorod\u0105 (<code>&amp;</code>)</p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#5-zingsnis-evoliucija-vectorint-vectorstring","title":"5 \u017eingsnis. Evoliucija: vector\\&lt;int&gt; \u2192 vector\\&lt;string&gt;","text":"<p>Reikalavimai: 1. Sukurkite nauj\u0105 programos versij\u0105, kuri:    - \u012eveda \u017eod\u017eius (ne skai\u010dius)    - Baigia \u012fvedim\u0105, kai \u012fvedamas <code>-</code>    - R\u016b\u0161iuoja \u017eod\u017eius ab\u0117c\u0117l\u0117s tvarka    - Atspausdina sur\u016b\u0161iuotus \u017eod\u017eius</p> <ol> <li>Naudokite <code>vector&lt;string&gt;</code> konteiner\u012f</li> <li>R\u016b\u0161iavimo funkcija turi veikti su <code>string</code> tipu</li> </ol> <p>SVARBU: - V\u0117l u\u017ekomentuokite sen\u0105 kod\u0105 (su <code>int</code>), bet palikite matytis</p> <p>Technikos: - <code>#include &lt;string&gt;</code> - <code>vector&lt;string&gt;</code> vietoj <code>vector&lt;int&gt;</code> - <code>string</code> tipas palaiko <code>&lt;</code> operatori\u0173 (ab\u0117c\u0117l\u0117s tvarka)</p> <p>Pavyzdys: <pre><code>\u012eveskite \u017eod\u017eius ('-' baigti):\nobuolys\nbananas\ncitrina\n-\nSur\u016b\u0161iuoti \u017eod\u017eiai: bananas citrina obuolys\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/U%C5%BEduotys/U1/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md              \u2190 Projekto README (\u017er. UzduotiuGidas.md)\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 U1/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 1 \u017eingsnis\n    \u2502   \u2514\u2500\u2500 main.cpp\n    \u251c\u2500\u2500 02/                \u2190 2 \u017eingsnis\n    \u2502   \u2514\u2500\u2500 main.cpp\n    \u251c\u2500\u2500 03/                \u2190 3 \u017eingsnis\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u251c\u2500\u2500 rusiavimas.h\n    \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 04/                \u2190 4 \u017eingsnis\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u251c\u2500\u2500 rusiavimas.h\n    \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 05/                \u2190 5 \u017eingsnis (FINAL)\n        \u251c\u2500\u2500 main.cpp\n        \u251c\u2500\u2500 rusiavimas.h\n        \u251c\u2500\u2500 rusiavimas.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/U%C5%BEduotys/U1/#git-workflow-tariamas","title":"Git workflow (tariamas):","text":"<p>Po kiekvieno \u017eingsnio: <pre><code>cd cpp-2026/U1/01/\n# ... atlikti darb\u0105 ...\n\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U1/#moodle-pateikimas-tariamas","title":"Moodle pateikimas (tariamas):","text":"<ol> <li> <p>Sukurti archyv\u0105:    <pre><code>cd cpp-2026\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/ README.md .gitignore\n</code></pre></p> </li> <li> <p>\u012ekelti \u012f Moodle su GitLab URL</p> </li> </ol>"},{"location":"Pratybos/U%C5%BEduotys/U1/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Perskaitykite U\u017eduo\u010di\u0173 Gidas prie\u0161 pradedant</li> <li>Git workflow:</li> <li>Commit'inkite po kiekvieno \u017eingsnio</li> <li>Push'inkite da\u017enai (backup!)</li> <li>Prad\u0117kite paprastai - pirmiausia paleiskite 1 \u017eingsn\u012f, tada t\u0119skite</li> <li>Kompiliuokite da\u017enai - po kiekvieno \u017eingsnio</li> <li>Testuokite su skirtingais duomenimis - teigiami, neigiami skai\u010diai</li> <li>Klauskite, jei neai\u0161ku - geriau anks\u010diau nei v\u0117liau!</li> </ol>"},{"location":"Pratybos/U%C5%BEduotys/U1/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ vector dokumentacija</li> <li>C++ string dokumentacija</li> <li>Makefile tutorial</li> </ul>"},{"location":"Pratybos/U%C5%BEduotys/U1/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Ar galiu naudoti <code>std::sort()</code> vietoj Bubble sort? A: Ne, \u0161ioje u\u017eduotyje privaloma implementuoti Bubble sort patys.</p> <p>K: Ar privalau naudoti Makefile? A: Ne, bet rekomenduojama nuo 3 \u017eingsnio. Galite kompiliuoti rankiniu b\u016bdu.</p> <p>K: Kiek test\u0173 reikia README faile? A: Bent 2 - vienas su skai\u010diais, vienas su \u017eod\u017eiais.</p> <p>K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173? A: Taip, bet neprivaloma. Subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/","title":"U2: OOP Pagrindai. Klas\u0117s ir Objektai","text":"<p>Savait\u0117s: 3-4 Svoris: 1 balas</p> <p>Versija: v.1</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>Priminimas: Taikomi tie patys reikalavimai kaip U1. \ud83d\udc49 U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>I\u0161mokti kurti C++ klases, j\u0173 egzempliorius - objektus; suvokti inkapsuliacijos princip\u0105; dirbti su konstruktoriais ir destruktoriais; panaudoti statinius ir masyvinius klasi\u0173 (objekt\u0173) narius.</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Transformuoti C strukt\u016br\u0105 \u012f C++ klas\u0119 (<code>struct</code> \u012f <code>class</code>)</li> <li>\u2705 Naudoti <code>private</code> ir <code>public</code> prieigos modifikatorius</li> <li>\u2705 Kurti konstruktorius (default ir parametrinius)</li> <li>\u2705 Kurti ir naudoti getterius/setterius</li> <li>\u2705 Naudoti statinius narius (klas\u0117s lygio duomenys)</li> <li>\u2705 Ra\u0161yti destruktorius su logging</li> <li>\u2705 Dirbti su C-style masyvais klas\u0117je</li> <li>\u2705 (Bonus) pereiti nuo masyvo prie <code>vector</code></li> </ul>"},{"location":"Pratybos/U%C5%BEduotys/U2/#uzduoties-formatas","title":"\ud83d\udcd0 U\u017eduoties formatas","text":"<p>\u017dingsni\u0173 strukt\u016bra: - 5 pagrindiniai \u017eingsniai + 1 papildomas \u017eingsnis - \u017dingsniai 1-2: Pilni pavyzd\u017eiai (ap\u0161ilimas) - \u017dingsniai 3-6: J\u016bs\u0173 kodas pagal u\u017eduotis</p> <p>Kodo \u017eym\u0117jimai: - PAVYZDYS \u2014 pilnas veikiantis kodas (galite kopijuoti) - J\u016aS\u0172 KODAS \u2014 turite patys sukurti - // U\u017dDUOTIS: \u2014 komentarai nurodo, k\u0105 reikia padaryti</p> <p>Pavyzdys: <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar p tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: prid\u0117ti \u012f masyv\u0105\n}\n</code></pre></p> <p>Tai rei\u0161kia \u2014 j\u016bs ra\u0161ote kod\u0105, kuris atlieka tai, kas apra\u0161yta komentaruose.</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/U%C5%BEduotys/U2/#1-zingsnis-struct-class-transformacija","title":"1 \u017eingsnis: Struct \u2192 Class transformacija","text":"<p>Direktorija: <code>U2/01/</code></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#reikalavimai","title":"Reikalavimai:","text":"<p>Sukurkite 2 failus tame pa\u010diame \u017eingsnyje, kad b\u016bt\u0173 matoma transformacija:</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#failas-student_structcpp-c-strukturos-versija","title":"Failas <code>student_struct.cpp</code> - C strukt\u016bros versija:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nstruct Student {\n    char vardas[50];\n    int amzius;\n    double pazymys;\n};\n\nint main() {\n    Student s1;\n    strcpy(s1.vardas, \"Jonas\");\n    s1.amzius = 20;\n    s1.pazymys = 8.5;\n\n    cout &lt;&lt; \"Studentas: \" &lt;&lt; s1.vardas \n         &lt;&lt; \", Am\u017eius: \" &lt;&lt; s1.amzius \n         &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; s1.pazymys &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Kompiliavimas: <pre><code>g++ student_struct.cpp -o struct_versija\n./struct_versija\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#failas-student_classcpp-c-klases-versija-su-public-nariais","title":"Failas <code>student_class.cpp</code> - C++ klas\u0117s versija (su public nariais):","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Student {\npublic:  // Visi nariai public (kaip struct)\n    char vardas[50];\n    int amzius;\n    double pazymys;\n};\n\nint main() {\n    Student s1;\n    strcpy(s1.vardas, \"Petras\");\n    s1.amzius = 21;\n    s1.pazymys = 9.0;\n\n    cout &lt;&lt; \"Studentas: \" &lt;&lt; s1.vardas \n         &lt;&lt; \", Am\u017eius: \" &lt;&lt; s1.amzius \n         &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; s1.pazymys &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Kompiliavimas: <pre><code>g++ student_class.cpp -o class_versija\n./class_versija\n</code></pre></p> <p>Technikos: - <code>struct</code> - visi nariai public pagal nutyl\u0117jim\u0105 - <code>class</code> - visi nariai private pagal nutyl\u0117jim\u0105 - Parodyti skirtum\u0105 tarp <code>struct</code> (visk\u0105 galima pasiekti) ir <code>class</code> (reikia metod\u0173)</p> <p>Testas: <pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U2/01/\n\u251c\u2500\u2500 student_struct.cpp\n\u251c\u2500\u2500 student_class.cpp\n\u2514\u2500\u2500 README.md (neprivalomas)\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#2-zingsnis-konstruktoriai","title":"2 \u017eingsnis: Konstruktoriai","text":"<p>Direktorija: <code>U2/02/</code></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#reikalavimai_1","title":"Reikalavimai:","text":"<p>Sukurkite Student klas\u0119 su konstruktoriais:</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#student-klase","title":"Student klas\u0117:","text":"<p>Private nariai: - <code>char vardas[50]</code> - studento vardas - <code>int amzius</code> - studento am\u017eius - <code>double pazymys</code> - studento pa\u017eymys (vienas)</p> <p>Public konstruktoriai:</p> <p>1. Default konstruktorius: <pre><code>Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    cout &lt;&lt; \"[TEST] Student sukurtas (default): \" &lt;&lt; vardas &lt;&lt; endl;\n}\n</code></pre></p> <p>2. Parametrinis konstruktorius: <pre><code>Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    cout &lt;&lt; \"[TEST] Student sukurtas: \" &lt;&lt; vardas &lt;&lt; endl;\n}\n</code></pre></p> <p>Technikos: - Naudokite <code>strcpy()</code> (i\u0161 <code>&lt;cstring&gt;</code>) C-style string'ams - Konstruktoriai inicializuoja objekt\u0105 suk\u016brimo metu - Logging padeda matyti, kada objektai kuriami</p> <p>Testas: <pre><code>int main() {\n    Student s1;  // Default konstruktorius\n    Student s2(\"Jonas\", 20, 8.5);  // Parametrinis\n    Student s3(\"Petras\", 21, 9.0);\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>[TEST] Student sukurtas (default): Nezinomas\n[TEST] Student sukurtas: Jonas\n[TEST] Student sukurtas: Petras\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U2/02/\n\u251c\u2500\u2500 Student.h\n\u251c\u2500\u2500 Student.cpp\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 Makefile\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#3-zingsnis-metodai-getters-setters-utility","title":"3 \u017eingsnis: Metodai (getters, setters, utility)","text":"<p>Direktorija: <code>U2/03/</code></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#reikalavimai_2","title":"Reikalavimai:","text":"<p>Prid\u0117kite metodus prie Student klas\u0117s:</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#public-metodai","title":"Public metodai:","text":"<p>Getters (const metodai) - PAVYZDYS: <pre><code>const char* gautiVarda() const { \n    return vardas; \n}\n\nint gautiAmziu() const { \n    // U\u017dDUOTIS: gr\u0105\u017einti am\u017ei\u0173\n}\n\ndouble gautiPazymi() const { \n    // U\u017dDUOTIS: gr\u0105\u017einti pa\u017eym\u012f\n}\n</code></pre></p> <p>Setters - J\u016aS\u0172 KODAS: <pre><code>void nustatytiVarda(const char* v) {\n    // U\u017dDUOTIS: nukopijuoti vard\u0105 su strcpy()\n}\n\nvoid nustatytiAmziu(int a) {\n    // U\u017dDUOTIS: patikrinti ar am\u017eius tinkamas (&gt; 0 ir &lt; 120)\n    // U\u017dDUOTIS: jei taip - priskirti\n}\n\nvoid nustatytiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar pa\u017eymys tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: jei taip - priskirti\n}\n</code></pre></p> <p>Pagalbiniai metodai - J\u016aS\u0172 KODAS: <pre><code>bool arPilnametis() const {\n    // U\u017dDUOTIS: gr\u0105\u017einti true jei amzius &gt;= 18, kitaip false\n}\n\nvoid spausdinti() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Studentas: &lt;vardas&gt;, Am\u017eius: &lt;amzius&gt;, Pa\u017eymys: &lt;pazymys&gt;\"\n    // U\u017dDUOTIS: jei pilnametis, prid\u0117ti \" (pilnametis)\"\n}\n</code></pre></p> <p>Technikos: - <code>const</code> metodai - nekei\u010dia objekto b\u016bsenos! - Getters - tik skaito duomenis - Setters - modifikuoja duomenis (su patvirtinimu!) - Pagalbiniai metodai - skai\u010diuoja ar tikrina logik\u0105</p> <p>Testas: <pre><code>int main() {\n    Student s1(\"Jonas\", 20, 8.5);\n    s1.spausdinti();\n\n    s1.nustatytiPazymi(9.0);\n    cout &lt;&lt; \"Naujas pa\u017eymys: \" &lt;&lt; s1.gautiPazymi() &lt;&lt; endl;\n\n    Student s2(\"Petras\", 16, 7.5);\n    s2.spausdinti();\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5 (pilnametis)\nNaujas pa\u017eymys: 9\nStudentas: Petras, Am\u017eius: 16, Pa\u017eymys: 7.5\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#4-zingsnis-static-skaitiklis-counter-destruktorius","title":"4 \u017eingsnis: Static skaitiklis (counter) + destruktorius","text":"<p>Direktorija: <code>U2/04/</code></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#reikalavimai_3","title":"Reikalavimai:","text":"<p>Prid\u0117kite statin\u012f nar\u012f ir destruktori\u0173:</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#studenth","title":"Student.h:","text":"<pre><code>class Student {\nprivate:\n    char vardas[50];\n    int amzius;\n    double pazymys;\n\n    static int sukurtaStudentu;  // Statinis skaitiklis\n\npublic:\n    Student();  // Default konstruktorius\n    Student(const char* v, int a, double p);  // Parametrinis\n    ~Student();  // Destruktorius\n\n    // Getters, setters, utility metodai...\n\n    static int gautiSukurtaStudentu();  // Static getter\n};\n</code></pre>"},{"location":"Pratybos/U%C5%BEduotys/U2/#studentcpp","title":"Student.cpp:","text":"<p>Statinio nario inicializacija (u\u017e klas\u0117s rib\u0173!): <pre><code>int Student::sukurtaStudentu = 0;\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    // U\u017dDUOTIS: padidinti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti [TEST] \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n\nStudent::Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    // U\u017dDUOTIS: padidinti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti [TEST] \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n</code></pre></p> <p>Destruktorius - J\u016aS\u0172 KODAS: <pre><code>Student::~Student() {\n    // U\u017dDUOTIS: suma\u017einti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti [TEST] \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n</code></pre></p> <p>Static getter: <pre><code>int Student::gautiSukurtaStudentu() {\n    return sukurtaStudentu;\n}\n</code></pre></p> <p>Technikos: - Static narys - bendras visiems objektams (objektai neturi \u0161io nario (\u0161ios dalies) savyje) - Inicializuoti u\u017e klas\u0117s rib\u0173: <code>int Student::sukurtaStudentu = 0;</code> - Destruktorius - automati\u0161kai kvie\u010diamas, kai objektas \"mir\u0161ta\" (baigiasi jo gyvavimo ciklas) - Alternatyva: Inicializavimo s\u0105ra\u0161as konstruktoriuje (modernesn\u0117 C++ praktika):   <pre><code>Student::Student(const char* v, int a, double p) \n    : amzius(a), pazymys(p)  // Initialization list\n{\n    strcpy(vardas, v);  // char[] reikia body'je\n    sukurtaStudentu++;\n}\n</code></pre></p> <p>Testas: <pre><code>int main() {\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    {\n        Student s1(\"Jonas\", 20, 8.5);\n        Student s2(\"Petras\", 21, 9.0);\n        cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 2\n    }  // s1 ir s2 sunaikinami \u010dia\n\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>Student\u0173: 0\n[TEST] Student sukurtas: Jonas. Viso student\u0173: 1\n[TEST] Student sukurtas: Petras. Viso student\u0173: 2\nStudent\u0173: 2\n[TEST] Student sunaikintas: Petras. Liko student\u0173: 1\n[TEST] Student sunaikintas: Jonas. Liko student\u0173: 0\nStudent\u0173: 0\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#5-zingsnis-pazymiu-masyvas","title":"5 \u017eingsnis: Pa\u017eymi\u0173 masyvas","text":"<p>Direktorija: <code>U2/05/</code></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#reikalavimai_4","title":"Reikalavimai:","text":"<p>Pakeiskite klas\u0119 - vietoj vieno pa\u017eymio naudokite pa\u017eymi\u0173 masyv\u0105:</p> <p>Private nariai: <pre><code>private:\n    char vardas[50];\n    int amzius;\n\n    // NAUJAS KODAS: pa\u017eymi\u0173 masyvas\n    static const int MAX_PAZYMIU = 20;\n    double pazymiai[MAX_PAZYMIU];\n    int pazymiuKiekis;\n\n    static int sukurtaStudentu;\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymiuKiekis = 0;  // Prad\u017eioje 0 pa\u017eymi\u0173\n    sukurtaStudentu++;\n    // ...\n}\n\nStudent::Student(const char* v, int a) {  // Be pa\u017eymio!\n    strcpy(vardas, v);\n    amzius = a;\n    pazymiuKiekis = 0;\n    sukurtaStudentu++;\n    // ...\n}\n</code></pre></p> <p>Nauji metodai - J\u016aS\u0172 KODAS:</p> <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar pazymiuKiekis &lt; MAX_PAZYMIU\n    // U\u017dDUOTIS: patikrinti ar pa\u017eymys tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: jei viskas OK - prid\u0117ti \u012f masyv\u0105 ir padidinti kiek\u012f\n    // U\u017dDUOTIS: jei ne - i\u0161spausdinti klaidos prane\u0161im\u0105\n}\n\ndouble skaiciuotiVidurki() const {\n    // U\u017dDUOTIS: jei pazymiuKiekis == 0, gr\u0105\u017einti 0.0\n    // U\u017dDUOTIS: suskai\u010diuoti sum\u0105 vis\u0173 pa\u017eymi\u0173 (naudoti for cikl\u0105)\n    // U\u017dDUOTIS: gr\u0105\u017einti suma / pazymiuKiekis\n}\n\nvoid spausdintiPazymius() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Pa\u017eymiai (&lt;kiekis&gt;): \"\n    // U\u017dDUOTIS: i\u0161spausdinti visus pa\u017eymius atskiriant kableliais\n    // Pavyzdys: \"Pa\u017eymiai (4): 8.5, 9, 7.5, 8\"\n}\n</code></pre> <p>Atnaujinta <code>spausdinti()</code> - J\u016aS\u0172 KODAS: <pre><code>void spausdinti() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Studentas: &lt;vardas&gt;, Am\u017eius: &lt;amzius&gt;\"\n    // U\u017dDUOTIS: i\u0161kviesti spausdintiPazymius()\n    // U\u017dDUOTIS: i\u0161spausdinti \"Vidurkis: &lt;vidurkis&gt;\"\n}\n</code></pre></p> <p>Testas: <pre><code>int main() {\n    Student s1(\"Jonas\", 20);\n\n    s1.pridetiPazymi(8.5);\n    s1.pridetiPazymi(9.0);\n    s1.pridetiPazymi(7.5);\n    s1.pridetiPazymi(8.0);\n\n    s1.spausdinti();\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>[TEST] Student sukurtas: Jonas. Viso student\u0173: 1\nStudentas: Jonas, Am\u017eius: 20\nPa\u017eymiai (4): 8.5, 9, 7.5, 8\nVidurkis: 8.25\n[TEST] Student sunaikintas: Jonas. Liko student\u0173: 0\n</code></pre></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#6-zingsnis-bonus-02-balo-masyvas-vector","title":"6 \u017eingsnis (BONUS +0.2 balo): Masyvas \u2192 vector","text":"<p>Direktorija: <code>U2/06-bonus/</code></p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#reikalavimai_5","title":"Reikalavimai:","text":"<p>Pakeiskite masyv\u0105 \u012f <code>vector&lt;double&gt;</code> (kaip U1 \u017eingsnis 4):</p> <p>Student.h: <pre><code>#include &lt;vector&gt;  // SVARBU!\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n\n    // NAUJAS KODAS: vector\n    vector&lt;double&gt; pazymiai;\n\n    static int sukurtaStudentu;\n\npublic:\n    // ...\n};\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    // pazymiai jau tu\u0161\u010dias vector (default konstruktorius)\n    sukurtaStudentu++;\n}\n</code></pre></p> <p>Atnaujinti metodai - J\u016aS\u0172 KODAS:</p> <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar p tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: naudoti pazymiai.push_back(p)\n}\n\ndouble skaiciuotiVidurki() const {\n    // U\u017dDUOTIS: patikrinti ar pazymiai.empty()\n    // U\u017dDUOTIS: suskai\u010diuoti sum\u0105 (galite naudoti range-based for: for (double p : pazymiai))\n    // U\u017dDUOTIS: gr\u0105\u017einti suma / pazymiai.size()\n}\n\nvoid spausdintiPazymius() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Pa\u017eymiai (&lt;pazymiai.size()&gt;): \"\n    // U\u017dDUOTIS: iteruoti per pazymiai ir spausdinti\n}\n</code></pre> <p>PRIVALUMAI: - \u2705 Dinaminis dydis (ne limitai!) - \u2705 Paprastesnis kodas (<code>push_back()</code>, <code>size()</code>, <code>empty()</code>) - \u2705 Range-based for loop (moderni\u0161kas C++)</p> <p>Testas: tas pats kaip \u017eingsnis 5, bet be limit\u0173.</p>"},{"location":"Pratybos/U%C5%BEduotys/U2/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/U%C5%BEduotys/U2/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/\n\u2514\u2500\u2500 U2/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 Struct \u2192 Class\n    \u2502   \u251c\u2500\u2500 student_struct.cpp\n    \u2502   \u2514\u2500\u2500 student_class.cpp\n    \u251c\u2500\u2500 02/                \u2190 Konstruktoriai\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 03/                \u2190 Metodai (getters/setters)\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 04/                \u2190 Static + destruktorius\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 05/                \u2190 Pa\u017eymi\u0173 masyvas (FINAL)\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 06-bonus/          \u2190 BONUS: vector (neprivalomas)\n        \u251c\u2500\u2500 Student.h\n        \u251c\u2500\u2500 Student.cpp\n        \u251c\u2500\u2500 main.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/U%C5%BEduotys/U2/#git-workflow","title":"Git workflow:","text":"<pre><code>git add U2/01/\ngit commit -m \"U2: 1 \u017eingsnis - Struct \u2192 Class transformacija\"\ngit push\n\ngit add U2/02/\ngit commit -m \"U2: 2 \u017eingsnis - Konstruktoriai\"\ngit push\n\n# ... ir t.t.\n</code></pre>"},{"location":"Pratybos/U%C5%BEduotys/U2/#u2readmemd-sablonas","title":"U2/README.md \u0161ablonas:","text":"<pre><code># U2: OOP Pagrindai. Klas\u0117s ir Objektai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-03-01\n\n---\n\n## \ud83d\udcc1 \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Struct \u2192 Class transformacija |\n| 2 | `02/` | Konstruktoriai (default + parametrinis) |\n| 3 | `03/` | Metodai (getters, setters, pagalbiniai) |\n| 4 | `04/` | Static counter + destruktorius |\n| 5 | `05/` | Pa\u017eymi\u0173 masyvas |\n| 6 | `06-bonus/` | BONUS: array \u2192 vector |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (konstruktoriai)**:\n\n    [TEST] Student sukurtas: Jonas. Viso student\u0173: 1\n    \u2705 VEIKIA\n\n**Testas 2 (pa\u017eymi\u0173 vidurkis)**:\n\n    Pa\u017eymiai (4): 8.5, 9, 7.5, 8\n    Vidurkis: 8.25\n    \u2705 VEIKIA\n\n---\n\n## \ud83d\udcad \u012e\u017evalgos, pasteb\u0117jimai\n</code></pre>"},{"location":"Pratybos/U%C5%BEduotys/U2/#moodle-pateikimas-pavyzdys","title":"Moodle pateikimas (pavyzdys):","text":"<pre><code>cd cpp-2026\ngit archive --format=zip --output=U2_VardasPavarde.zip HEAD U2/ README.md .gitignore\n</code></pre>"},{"location":"Pratybos/U%C5%BEduotys/U2/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Struct vs Class:</li> <li><code>struct</code> - <code>public</code> pagal nutyl\u0117jim\u0105</li> <li> <p><code>class</code> - <code>private</code> pagal nutyl\u0117jim\u0105</p> </li> <li> <p>Konstruktoriai:</p> </li> <li>Naudokite <code>strcpy()</code> C-style string'ams</li> <li> <p>Inicializuokite visus narius</p> </li> <li> <p>Static nariai:</p> </li> <li>Deklaruoti klas\u0117je: <code>static int sukurtaStudentu;</code></li> <li> <p>Inicializuoti u\u017e klas\u0117s rib\u0173 (<code>.cpp</code>): <code>int Student::sukurtaStudentu = 0;</code></p> </li> <li> <p>Const metodai:</p> </li> <li>Getters visada <code>const</code></li> <li> <p>Pagalbiniai metodai, kurie nekei\u010dia objekto - <code>const</code></p> </li> <li> <p>Patikrinimas:</p> </li> <li>Am\u017eius: <code>&gt; 0 &amp;&amp; &lt; 120</code></li> <li>Pa\u017eymys: <code>&gt;= 0.0 &amp;&amp; &lt;= 10.0</code></li> <li> <p>Masyvo ribos: <code>pazymiuKiekis &lt; MAX_PAZYMIU</code></p> </li> <li> <p>Sen\u0105 kod\u0105 galite i\u0161trinti - Git saugo vis\u0105 istorij\u0105 commit'uose</p> </li> </ol>"},{"location":"Pratybos/U%C5%BEduotys/U2/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ classes</li> <li>Constructors</li> <li>Destructors</li> <li>Static members</li> <li>Vector container</li> </ul>"},{"location":"Pratybos/U%C5%BEduotys/U2/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Kod\u0117l <code>strcpy()</code> vietoj <code>string</code>? A: Demonstruoti C-style string'us (tradicin\u0117 sintaks\u0117). V\u0117liau (U3+) naudosime <code>std::string</code>.</p> <p>K: Ar privaloma naudoti <code>const</code> metodams? A: Taip, getters ir utility metodai turi b\u016bti <code>const</code> (gera praktika).</p> <p>K: Kod\u0117l static narys inicializuojamas u\u017e klas\u0117s? A: Nes static narys - bendras visiems objektams, ne kiekvieno objekto dalis. Reikia vienos kopijos visai klasei.</p> <p>K: Ar destruktorius visada automatinis? A: Taip, destruktorius automati\u0161kai kvie\u010diamas, kai objektas i\u0161eina i\u0161 scope (arba <code>delete</code> jei dinaminis).</p> <p>K: Ar \u017eingsnis 6 (bonus) privalomas? A: Ne, tai bonus (+0.2 balo). Bet rekomenduojamas visiems studentams.</p>"},{"location":"Temos/Better_C/ParamPass/","title":"Parametr\u0173 perdavimo mechanizmai","text":""},{"location":"Temos/Better_C/ParamPass/#value-vs-pointer-vs-reference","title":"Value vs. Pointer vs. Reference","text":""},{"location":"Temos/Better_C/ParamPass/#1-perdavimas-pagal-reiksme-callpass-by-value","title":"1. Perdavimas pagal reik\u0161m\u0119 (call/pass by value)","text":"<p>Tai vienintelis \"tikras\" C kalbos mechanizmas.</p> <ul> <li>\u012e funkcij\u0105 perduodamos kopijos.</li> <li>Funkcija turi savo lokalius kintamuosius (<code>temp</code>, <code>x</code>, <code>y</code>).</li> <li>Original\u016bs kintamieji <code>main</code> funkcijoje N\u0116RA kei\u010diami.</li> </ul>  Tai saugu, bet neefektyvu dideliems objektams ir netinka, kai norime pakeisti original\u0105.  <pre><code>void swap_val(int x, int y) { // Gauna KOPIJAS (x=1, y=2)\n    int temp = x;\n    x = y;\n    y = temp;\n} // \u010cia kopijos sunaikinamos. Originalai a ir b nepakito.\n</code></pre> <p>\ud83d\udc49 Python Tutor</p>"},{"location":"Temos/Better_C/ParamPass/#2-c-rodyklemis-imituojamas-perdavimas-pagal-nuoroda-callpass-by-reference","title":"2. C rodykl\u0117mis imituojamas perdavimas pagal nuorod\u0105 (\"call/pass by reference\")","text":"<p>C kalboje nor\u0117dami pakeisti original\u0105, turime \"gudrauti\" naudodami adresus.</p> <ol> <li>Parametrai tampa rodykl\u0117mis (<code>int*</code>).</li> <li>Naudojame i\u0161adresavimo (dereference) operatori\u0173 <code>*</code>, kad pasiektume reik\u0161m\u0119.</li> <li>Kvie\u010diant funkcij\u0105, siun\u010diame adresus (<code>&amp;a</code>).</li> </ol> <pre><code>void swap_ptr(int* x, int* y) { // Gauna ADRESUS\n    int temp = *x; // Paimk reik\u0161m\u0119 i\u0161 adreso x\n    *x = *y;       // \u012era\u0161yk y reik\u0161m\u0119 \u012f x adres\u0105\n    *y = temp;     // \u012era\u0161yk temp \u012f y adres\u0105\n}\n\n// Kvietimas: swap_ptr(&amp;a, &amp;b);\n</code></pre> <p>\ud83d\udc49 Python Tutor</p>"},{"location":"Temos/Better_C/ParamPass/#3-c-perdavimas-pagal-nuorodas-callpass-by-reference","title":"3. C++ perdavimas pagal nuorodas (call/pass by reference)","text":"<p>C++ \u012fveda tikr\u0105j\u012f perdavim\u0105 pagal nuorod\u0105. Nuoroda (<code>int&amp;</code>) \u2013 tai pseudonimas (alias). Tai lyg antras vardas tam pa\u010diam kintamajam.</p> <ul> <li>Sintaks\u0117 \u0161varesn\u0117 (nereikia <code>*</code> ir <code>&amp;</code> funkcijos viduje).</li> <li>Kompiliatorius u\u017etikrina, kad nuoroda visada \u012f ka\u017ek\u0105 rodyt\u0173.</li> </ul> <p><pre><code>void swap_cpp(int&amp; x, int&amp; y) { // x yra 'a' pseudonimas\n    int temp = x;\n    x = y;         // Kei\u010dia pat\u012f original\u0105\n    y = temp;\n}\n\n// Kvietimas: swap_cpp(a, b);  &lt;- Atrodo paprastai!\n</code></pre> \ud83d\udc49 Python Tutor</p>"},{"location":"Temos/Better_C/ParamPass/#apibendrinimas-3-budai","title":"Apibendrinimas: 3 b\u016bdai","text":"Savyb\u0117 By Value (C/C++) Pointer (C stilius) Reference (C++ stilius) Deklaracija <code>void f(int x)</code> <code>void f(int* x)</code> <code>void f(int&amp; x)</code> Kvietimas <code>f(a)</code> <code>f(&amp;a)</code> <code>f(a)</code> Veiksmas Dirba su kopija Dirba su adresu Dirba su originalu Sintaks\u0117 Paprasta Sud\u0117tinga (<code>*</code>, <code>&amp;</code>) Paprasta Verdiktas Saugus, bet \"lokalus\" Galingas, bet pavojingas Modernus standartas <pre><code>// Tik C++ leid\u017eia ra\u0161yti taip \u0161variai:\nint main() {\n    int a=1, b=2;\n    swap_cpp(a, b); // a=2, b=1\n}\n</code></pre>"}]}